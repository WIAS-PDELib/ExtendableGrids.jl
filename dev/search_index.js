var documenterSearchIndex = {"docs":
[{"location":"binnedpointlist/#BinnedPointList","page":"BinnedPointList","title":"BinnedPointList","text":"","category":"section"},{"location":"binnedpointlist/","page":"BinnedPointList","title":"BinnedPointList","text":"Used to find and identify points in space","category":"page"},{"location":"binnedpointlist/#API","page":"BinnedPointList","title":"API","text":"","category":"section"},{"location":"binnedpointlist/","page":"BinnedPointList","title":"BinnedPointList","text":"BinnedPointList\nfindpoint\nBase.insert!","category":"page"},{"location":"binnedpointlist/#ExtendableGrids.BinnedPointList","page":"BinnedPointList","title":"ExtendableGrids.BinnedPointList","text":"mutable struct BinnedPointList{T}\n\nBinned  point  list structure  allowing  for  fast check  for  already existing points.\n\nThis  provides better  performance for  indendifying already  inserted points than the naive linear search.\n\nOTOH  the  implementation  is  still  quite  naive  -  it  dynamically maintains a cuboid binning region with a fixed number of bins.\n\nProbably  tree based  adaptive  methods  (a la  octree)  will be  more efficient, however they will be harder to implement.\n\nIn an ideal world, we would maintain a dynamic Delaunay triangulation, which at  once could be  the starting  point of mesh  generation which will follow here anyway.\n\ndim::Int32:  Space dimension\n\ntol::Any: Point distance tolerance. Points closer than tol (in Euclidean distance) will be identified, i.e. are collapsed to the first inserted.\n\nbinning_region_min::Vector: \" The union of all bins is the binning region - a cuboid given by two of its corners. It is calculated dynamically depending on the inserted points.\n\nbinning_region_max::Vector\nbinning_region_increase_factor::Any: Increase factor of binning region (with respect to the cuboid defined by the coordinates of the binned points)\n\npoints::ElasticArrays.ElasticArray{T, 2, M, V} where {T, M, V<:DenseVector{T}}: The actual point list\n\nbins::Array{Vector{Int32}}: The bins are vectors of indices of points in the point list We store them in a dim-dimensional array  of length \"numberofdirectional_bins^dim\"\n\nnumber_of_directional_bins::Int32: Number of bins in each space dimension\n\nunbinned::Vector{Int32}: Some points will fall outside of the binning region. We collect them in vector of ubinned point indices\n\nnum_allowed_unbinned_points::Int32: Number of unbinned  points tolerated without rebinning\n\nmax_unbinned_ratio::Any: Maximum ratio of unbinned  points  in point list\n\ncurrent_bin::Vector{Int32}: Storage of current point bin\n\n\n\n\n\n","category":"type"},{"location":"binnedpointlist/#ExtendableGrids.findpoint","page":"BinnedPointList","title":"ExtendableGrids.findpoint","text":"findpoint(binnedpointlist, p)\n\nFind point in binned point list. Return its index in the point list if found, otherwise return 0.\n\n\n\n\n\n","category":"function"},{"location":"binnedpointlist/#Base.insert!","page":"BinnedPointList","title":"Base.insert!","text":" Base.insert!(binnedpointlist,p)\n\nIf another point with distance less the tol from p is in pointlist, return its index. Otherwise, insert point into pointlist.  p may be a vector or a tuple.\n\n\n\n\n\n Base.insert!(binnedpointlist,x)\n\nInsert 1D point via coordinate.\n\n\n\n\n\n Base.insert!(binnedpointlist,x,y,z)\n\nInsert 3D point via coordinates.\n\n\n\n\n\n","category":"function"},{"location":"binnedpointlist/#Internal","page":"BinnedPointList","title":"Internal","text":"","category":"section"},{"location":"binnedpointlist/","page":"BinnedPointList","title":"BinnedPointList","text":"ExtendableGrids._findpoint\nExtendableGrids._bin_of_point!\nExtendableGrids._rebin_all_points!\nExtendableGrids.naiveinsert!","category":"page"},{"location":"binnedpointlist/#ExtendableGrids._findpoint","page":"BinnedPointList","title":"ExtendableGrids._findpoint","text":"_findpoint(binnedpointlist, index, p)\n\nFind point in index list (by linear search) Return its index, or zero if not found\n\n\n\n\n\n","category":"function"},{"location":"binnedpointlist/#ExtendableGrids._bin_of_point!","page":"BinnedPointList","title":"ExtendableGrids._bin_of_point!","text":"_bin_of_point!(binnedpointlist, p)\n\nCalculate the bin of the point. Result is stored in bpl.current_bin\n\n\n\n\n\n","category":"function"},{"location":"binnedpointlist/#ExtendableGrids._rebin_all_points!","page":"BinnedPointList","title":"ExtendableGrids._rebin_all_points!","text":"_rebin_all_points!(bpl)\n\nRe-calculate binning if there are too many unbinned points This amounts to two steps:\n\nEnlarge binning area in order to include all points\nRe-calculate all point bins\n\n\n\n\n\n","category":"function"},{"location":"binnedpointlist/#ExtendableGrids.naiveinsert!","page":"BinnedPointList","title":"ExtendableGrids.naiveinsert!","text":"naiveinsert(binnedpointlist, p)\n\nInsert via linear search, without any binning. Just for being able to check of all of the above was worth the effort...\n\n\n\n\n\n","category":"function"},{"location":"script_examples/examples1d/#1D-Grid-examples","page":"examples1d","title":"1D Grid examples","text":"","category":"section"},{"location":"script_examples/examples1d/","page":"examples1d","title":"examples1d","text":"using ExtendableGrids","category":"page"},{"location":"script_examples/examples1d/#Interval-from-vector","page":"examples1d","title":"Interval from vector","text":"","category":"section"},{"location":"script_examples/examples1d/","page":"examples1d","title":"examples1d","text":"function interval_from_vector()\n    X = collect(0:0.05:1)\n    grid = simplexgrid(X)\nend","category":"page"},{"location":"script_examples/examples1d/","page":"examples1d","title":"examples1d","text":"(Image: )","category":"page"},{"location":"script_examples/examples1d/#Interval-with-local-refinement","page":"examples1d","title":"Interval with local refinement","text":"","category":"section"},{"location":"script_examples/examples1d/","page":"examples1d","title":"examples1d","text":"function interval_localref()\n    XLeft = geomspace(0.0, 0.5, 0.1, 0.01)\n    XRight = geomspace(0.5, 1.0, 0.01, 0.1)\n    X = glue(XLeft, XRight)\n    grid = simplexgrid(X)\nend","category":"page"},{"location":"script_examples/examples1d/","page":"examples1d","title":"examples1d","text":"(Image: )","category":"page"},{"location":"script_examples/examples1d/#Interval-with-multiple-regions","page":"examples1d","title":"Interval with  multiple regions","text":"","category":"section"},{"location":"script_examples/examples1d/","page":"examples1d","title":"examples1d","text":"function interval_multiregion()\n    X = collect(0:0.05:1)\n    grid = simplexgrid(X)\n    cellmask!(grid, [0.0], [0.5], 3)\n    bfacemask!(grid, [0.5], [0.5], 4)\n    grid\nend","category":"page"},{"location":"script_examples/examples1d/","page":"examples1d","title":"examples1d","text":"(Image: )","category":"page"},{"location":"script_examples/examples1d/#Multiple-regions-and-subgrid","page":"examples1d","title":"Multiple regions and subgrid","text":"","category":"section"},{"location":"script_examples/examples1d/","page":"examples1d","title":"examples1d","text":"function interval_subgrid()\n    X = collect(0:0.01:1)\n    grid = simplexgrid(X)\n    bfacemask!(grid, [0.5], [0.5], 3)\n    cellmask!(grid, [0.0], [0.25], 2)\n    cellmask!(grid, [0.20], [0.5], 3)\n    subgrid(grid, [2, 3])\nend","category":"page"},{"location":"script_examples/examples1d/","page":"examples1d","title":"examples1d","text":"(Image: )","category":"page"},{"location":"script_examples/examples1d/#CI-callbacks-for-[ExampleJuggler.jl](https://github.com/j-fu/ExampleJuggler.jl)","page":"examples1d","title":"CI callbacks  for ExampleJuggler.jl","text":"","category":"section"},{"location":"script_examples/examples1d/","page":"examples1d","title":"examples1d","text":"Unit tests","category":"page"},{"location":"script_examples/examples1d/","page":"examples1d","title":"examples1d","text":"using Test\n\nfunction runtests()\n    @test numbers_match(interval_from_vector(), 21, 20, 2)\n    @test numbers_match(interval_localref(), 27, 26, 2)\n    @test numbers_match(interval_multiregion(), 21, 20, 3)\n    @test numbers_match(interval_subgrid(), 51, 50, 2)\nend","category":"page"},{"location":"script_examples/examples1d/","page":"examples1d","title":"examples1d","text":"Plot generation","category":"page"},{"location":"script_examples/examples1d/","page":"examples1d","title":"examples1d","text":"using GridVisualize\nfunction generateplots(picdir; Plotter = nothing)\n    if isdefined(Plotter, :Makie)\n        size = (500, 200)\n        legend = :rt\n        Plotter.save(joinpath(picdir, \"interval_from_vector.png\"), gridplot(interval_from_vector(); Plotter, size, legend))\n        Plotter.save(joinpath(picdir, \"interval_localref.png\"), gridplot(interval_localref(); Plotter, size, legend))\n        Plotter.save(joinpath(picdir, \"interval_multiregion.png\"), gridplot(interval_multiregion(); Plotter, size, legend))\n        Plotter.save(joinpath(picdir, \"interval_subgrid.png\"), gridplot(interval_subgrid(); Plotter, size, legend))\n    end\nend","category":"page"},{"location":"script_examples/examples1d/","page":"examples1d","title":"examples1d","text":"","category":"page"},{"location":"script_examples/examples1d/","page":"examples1d","title":"examples1d","text":"This page was generated using Literate.jl.","category":"page"},{"location":"refinement/#Mesh-refinement","page":"Mesh refinement","title":"Mesh refinement","text":"","category":"section"},{"location":"refinement/#API","page":"Mesh refinement","title":"API","text":"","category":"section"},{"location":"refinement/","page":"Mesh refinement","title":"Mesh refinement","text":"Modules = [ExtendableGrids]\nPages = [\"meshrefinements.jl\",\"adaptive_meshrefinements.jl\"]","category":"page"},{"location":"refinement/#ExtendableGrids.RGB_refine-Union{Tuple{K}, Tuple{T}, Tuple{ExtendableGrid{T, K}, Vector{Bool}}} where {T, K}","page":"Mesh refinement","title":"ExtendableGrids.RGB_refine","text":"RGB_refine(\n    source_grid::ExtendableGrid{T, K},\n    facemarkers::Vector{Bool};\n    store_parents\n) -> ExtendableGrid\n\n\ngenerates a new ExtendableGrid by red-green-blue mesh refinement of triangular meshes, see e.g.\n\nCarstensen, C. –An Adaptive Mesh-Refining Algorithm Allowing for an H^1 Stable L^2 Projection onto Courant Finite Element Spaces– Constr Approx 20, 549–564 (2004). https://doi.org/10.1007/s00365-003-0550-5\n\nThe bool array facemarkers determines which faces should be bisected. Note, that a closuring is performed such that the first face in every triangle with a marked face is also refined.\n\n\n\n\n\n","category":"method"},{"location":"refinement/#ExtendableGrids.barycentric_refine-Union{Tuple{ExtendableGrid{T, K}}, Tuple{K}, Tuple{T}} where {T, K}","page":"Mesh refinement","title":"ExtendableGrids.barycentric_refine","text":"barycentric_refine(\n    source_grid::ExtendableGrid{T, K};\n    store_parents\n) -> ExtendableGrid\n\n\ngenerates a new ExtendableGrid by barycentric refinement of each cell in the source grid\n\nbarycentric refinement is available for these ElementGeometries\n\nQuadrilateral2D (first split into Triangle2D)\nTriangle2D\n\n\n\n\n\n","category":"method"},{"location":"refinement/#ExtendableGrids.split_grid_into-Union{Tuple{K}, Tuple{T}, Tuple{ExtendableGrid{T, K}, Type{<:AbstractElementGeometry}}} where {T, K}","page":"Mesh refinement","title":"ExtendableGrids.split_grid_into","text":"split_grid_into(\n    source_grid::ExtendableGrid{T, K},\n    targetgeometry::Type{<:AbstractElementGeometry};\n    store_parents\n) -> ExtendableGrid\n\n\ngenerates a new ExtendableGrid by splitting each cell into subcells of the specified targetgeometry\n\nsplit rules exist for\n\nQuadrilateral2D into Triangle2D\nHexahedron3D into Tetrahedron3D\n\n\n\n\n\n","category":"method"},{"location":"refinement/#ExtendableGrids.uniform_refine-Union{Tuple{ExtendableGrid{T, K}}, Tuple{K}, Tuple{T}} where {T, K}","page":"Mesh refinement","title":"ExtendableGrids.uniform_refine","text":"uniform_refine(\n    source_grid::ExtendableGrid{T, K};\n    store_parents\n) -> ExtendableGrid\n\n\ngenerates a new ExtendableGrid by uniform refinement of each cell in the given grid\n\nuniform refinement rules are available for these AbstractElementGeometries:\n\nLine1D (bisection into two subsegments)\nTriangle2D (red refinement into four subtriangles)\nQuadrilateral2D (into four subquadrilaterals)\nTetrahedron (into eight subtetrahedrons)\nHexahedron (into eight subhexahedrons)\n\nif multiple geometries are in the mesh uniform refinement will only work if all refinement rules refine faces and edges (in 3D) equally (so no hanging nodes are created)\n\n\n\n\n\n","category":"method"},{"location":"script_examples/examples3d/#3D-Grid-examples","page":"examples3d","title":"3D Grid examples","text":"","category":"section"},{"location":"script_examples/examples3d/","page":"examples3d","title":"examples3d","text":"using ExtendableGrids","category":"page"},{"location":"script_examples/examples3d/#Quadrilateral","page":"examples3d","title":"Quadrilateral","text":"","category":"section"},{"location":"script_examples/examples3d/","page":"examples3d","title":"examples3d","text":"function quadrilateral(; hx = 0.25, hy = 0.2, hz = 0.1)\n    X = collect(0:hx:1)\n    Y = collect(0:hy:1)\n    Z = collect(0:hz:1)\n    simplexgrid(X, Y, Z)\nend","category":"page"},{"location":"script_examples/examples3d/","page":"examples3d","title":"examples3d","text":"(Image: )","category":"page"},{"location":"script_examples/examples3d/#Cross3d","page":"examples3d","title":"Cross3d","text":"","category":"section"},{"location":"script_examples/examples3d/","page":"examples3d","title":"examples3d","text":"function cross3d()\n    X = collect(0:0.1:1)\n    Y = collect(0:0.1:1)\n    Z = collect(0:0.1:1)\n    grid = simplexgrid(X, Y, Z)\n\n    rect!(grid, (0, 0.4, 0), (1, 0.6, 0.2); region = 2, bregions = [1, 1, 1, 1, 2, 3])\n\n    rect!(grid, (0.4, 0, 0.2), (0.6, 1, 0.4); region = 2, bregions = [4, 4, 4, 4, (cur) -> cur == 3 ? 0 : 5, 6])\n\n    subgrid(grid, [2])\nend","category":"page"},{"location":"script_examples/examples3d/","page":"examples3d","title":"examples3d","text":"(Image: )","category":"page"},{"location":"script_examples/examples3d/#CI-callbacks-for-[ExampleJuggler.jl](https://github.com/j-fu/ExampleJuggler.jl)","page":"examples3d","title":"CI callbacks  for ExampleJuggler.jl","text":"","category":"section"},{"location":"script_examples/examples3d/","page":"examples3d","title":"examples3d","text":"Unit tests","category":"page"},{"location":"script_examples/examples3d/","page":"examples3d","title":"examples3d","text":"function mask_bedges()\n    grid = quadrilateral(; hx = 0.25, hy = 0.25, hz = 0.25)\n\n    bedgemask!(grid, [0.0, 0.0, 0.0], [0.0, 0.0, 1.0], 1)\n    bedgemask!(grid, [0.0, 0.0, 0.0], [0.0, 1.0, 0.0], 2)\n    bedgemask!(grid, [0.0, 1.0, 0.0], [0.0, 1.0, 1.0], 3)\n    bedgemask!(grid, [0.0, 0.0, 1.0], [0.0, 1.0, 1.0], 4)\n    bedgemask!(grid, [0.0, 1.0, 0.0], [0.0, 0.0, 1.0], 5)\n\n    true\nend\n\nusing Test\n\nfunction runtests()\n    @test numbers_match(quadrilateral(), 330, 1200, 440)\n    @test mask_bedges()\n    @test numbers_match(cross3d(), 189, 480, 344)\nend","category":"page"},{"location":"script_examples/examples3d/","page":"examples3d","title":"examples3d","text":"Plot generation","category":"page"},{"location":"script_examples/examples3d/","page":"examples3d","title":"examples3d","text":"using GridVisualize\nfunction generateplots(picdir; Plotter = nothing)\n    if isdefined(Plotter, :Makie)\n        size = (400, 400)\n        Plotter.save(joinpath(picdir, \"quadrilateral.png\"), gridplot(quadrilateral(); Plotter, size))\n        Plotter.save(joinpath(picdir, \"cross3d.png\"), gridplot(cross3d(); Plotter, size))\n    end\nend","category":"page"},{"location":"script_examples/examples3d/","page":"examples3d","title":"examples3d","text":"","category":"page"},{"location":"script_examples/examples3d/","page":"examples3d","title":"examples3d","text":"This page was generated using Literate.jl.","category":"page"},{"location":"assembly/#Assembly-support","page":"Assembly support","title":"Assembly support","text":"","category":"section"},{"location":"assembly/#API","page":"Assembly support","title":"API","text":"","category":"section"},{"location":"assembly/","page":"Assembly support","title":"Assembly support","text":"Modules = [ExtendableGrids]\nPages = [\"assemblytypes.jl\",\"l2gtransformations.jl\"]","category":"page"},{"location":"assembly/#ExtendableGrids.AT_NODES","page":"Assembly support","title":"ExtendableGrids.AT_NODES","text":"abstract type AT_NODES <: AssemblyType\n\ncauses interpolation at vertices of the grid (only for H1-conforming interpolations)\n\n\n\n\n\n","category":"type"},{"location":"assembly/#ExtendableGrids.ON_BEDGES","page":"Assembly support","title":"ExtendableGrids.ON_BEDGES","text":"abstract type ON_BEDGES <: AssemblyType\n\ncauses assembly/interpolation on boundary edges of the grid (only in 3D)\n\n\n\n\n\n","category":"type"},{"location":"assembly/#ExtendableGrids.ON_BFACES","page":"Assembly support","title":"ExtendableGrids.ON_BFACES","text":"abstract type ON_BFACES <: AssemblyType\n\ncauses assembly/interpolation on boundary faces of the grid\n\n\n\n\n\n","category":"type"},{"location":"assembly/#ExtendableGrids.ON_CELLS","page":"Assembly support","title":"ExtendableGrids.ON_CELLS","text":"abstract type ON_CELLS <: AssemblyType\n\ncauses assembly/interpolation on cells of the grid\n\n\n\n\n\n","category":"type"},{"location":"assembly/#ExtendableGrids.ON_EDGES","page":"Assembly support","title":"ExtendableGrids.ON_EDGES","text":"abstract type ON_EDGES <: AssemblyType\n\ncauses assembly/interpolation on edges of the grid (only in 3D)\n\n\n\n\n\n","category":"type"},{"location":"assembly/#ExtendableGrids.ON_FACES","page":"Assembly support","title":"ExtendableGrids.ON_FACES","text":"abstract type ON_FACES <: AssemblyType\n\ncauses assembly/interpolation on faces of the grid\n\n\n\n\n\n","category":"type"},{"location":"assembly/#ExtendableGrids.ON_IFACES","page":"Assembly support","title":"ExtendableGrids.ON_IFACES","text":"abstract type ON_IFACES <: ON_FACES\n\ncauses assembly/interpolation on interior faces of the grid\n\n\n\n\n\n","category":"type"},{"location":"assembly/#ExtendableGrids.L2GTransformer","page":"Assembly support","title":"ExtendableGrids.L2GTransformer","text":"L2GTransformer\n\nTransforms reference coordinates to global coordinates\n\n\n\n\n\n","category":"type"},{"location":"output/#Grid-output","page":"Grid output","title":"Grid output","text":"","category":"section"},{"location":"output/","page":"Grid output","title":"Grid output","text":"Base.write\nwriteVTK","category":"page"},{"location":"output/#Base.write","page":"Grid output","title":"Base.write","text":"write(fname::String, g::ExtendableGrid; format)\n\n\nWrite grid to file. Currently for pdelib sg and Gmsh formats.\n\n\n\n\n\n","category":"function"},{"location":"output/#ExtendableGrids.writeVTK","page":"Grid output","title":"ExtendableGrids.writeVTK","text":"writeVTK(\n    filename::String,\n    grid::ExtendableGrid{Tc, Ti};\n    kwargs...\n) -> Vector{String}\n\n\nexports grid and optional provided data as a vtk file\n\nfilename: filename of the exported file\ngrid: grid\n\nEach '(key, value)' pair adds another data entry to the vtk file via WriteVTK functionality.\n\n\n\n\n\n","category":"function"},{"location":"voronoi/#Voronoi-tools","page":"Voronoi tools","title":"Voronoi tools","text":"","category":"section"},{"location":"voronoi/#API","page":"Voronoi tools","title":"API","text":"","category":"section"},{"location":"voronoi/","page":"Voronoi tools","title":"Voronoi tools","text":"Modules = [ExtendableGrids]\nPages = [\"voronoi.jl\"]","category":"page"},{"location":"voronoi/#ExtendableGrids.VoronoiFaceCenters","page":"Voronoi tools","title":"ExtendableGrids.VoronoiFaceCenters","text":"abstract type VoronoiFaceCenters <: AbstractGridFloatArray2D\n\nCenters of voronoi cell facets (currently 1D, 2D).\n\n\n\n\n\n","category":"type"},{"location":"voronoi/#ExtendableGrids.tricircumcenter!-NTuple{4, Any}","page":"Voronoi tools","title":"ExtendableGrids.tricircumcenter!","text":"tricircumcenter!(circumcenter, a, b, c)\n\n\nFind the circumcenter of a triangle.                 \n\nDerived from C source of Jonathan R Shewchuk <jrs@cs.cmu.edu>\n\nModified to return absolute coordinates.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"allindex/#Types-and-Constructors","page":"Index","title":"Types and Constructors","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"Modules = [ExtendableGrids]\nOrder=[:type]","category":"page"},{"location":"allindex/#Constants","page":"Index","title":"Constants","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"Modules = [ExtendableGrids]\nOrder=[:constant]","category":"page"},{"location":"allindex/#Methods","page":"Index","title":"Methods","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"Modules = [ExtendableGrids]\nOrder=[:function]","category":"page"},{"location":"gridconstructors/#Grid-constructors","page":"Grid constructors","title":"Grid constructors","text":"","category":"section"},{"location":"gridconstructors/#Tensor-product-simplex-grids","page":"Grid constructors","title":"Tensor product simplex grids","text":"","category":"section"},{"location":"gridconstructors/","page":"Grid constructors","title":"Grid constructors","text":"simplexgrid\nglue","category":"page"},{"location":"gridconstructors/#ExtendableGrids.simplexgrid","page":"Grid constructors","title":"ExtendableGrids.simplexgrid","text":"function simplexgrid(coord::Array{Tc,2},\n                     cellnodes::Array{Ti,2},\n                     cellregions,\n                     bfacenodes,\n                     bfaceregions\n                     ) where {Tc,Ti}\n\nCreate  d-dimensional simplex grid from five arrays.\n\n   coord: d ``\\times`` n_points matrix of coordinates\ncellnodes: d+1 times n_tri matrix of triangle - point incidence\ncellregions: n_tri vector of cell region markers\nbfacenodes: d times n_bf matrix of boundary facet - point incidences\nbfaceregions: n_bf vector of boundary facet  region markers\n\nCoordinate type Tc index type Ti are detected from the first two parameters. cellregions, bfaceregions, bfacenodes are converted to have the same element type as cellnodes.\n\n\n\n\n\nfunction simplexgrid(coord::Array{Tc,2},\n                     cellnodes::Array{Ti,2},\n                     cellregions,\n                     bfacenodes,\n                     bfaceregions,\n                     bedgenodes,\n                     bedgeregions\n                     ) where {Tc,Ti}\n\nCreate simplex grid from coordinates, cell-nodes-adjancency, cell-region-numbers, boundary-face-nodes adjacency, boundary-face-region-numbers, boundary-edge-nodes, and boundary-edge-region-numbers arrays.\n\nThe index type Ti is detected from cellnodes, all other arrays besides coord are converted to this index type.\n\n\n\n\n\nsimplexgrid(X; bregions=[1,2],cellregion=1)\n\nConstructor for 1D grid.\n\nConstruct 1D grid from an array of node cordinates. It creates two boundary regions with index 1 at the left end and index 2 at the right end by default.\n\nThe keyword arguments allow to overwrite the default region numbers.\n\nPrimal grid holding unknowns: marked by o, dual grid marking control volumes: marked by |.\n\n o-----o-----o-----o-----o-----o-----o-----o-----o\n |--|-----|-----|-----|-----|-----|-----|-----|--|\n\n\n\n\n\nsimplexgrid(X,Y; bregions=[1,2,3,4],cellregion=1)\n\nConstructor for 2D grid from coordinate arrays. \n\nBoundary region numbers count counterclockwise:\n\nlocation number\nsouth 1\neast 2\nnorth 3\nwest 4\n\nThe keyword arguments allow to overwrite the default region numbers.\n\n\n\n\n\nsimplexgrid(X,Y,Z; bregions=[1,2,3,4,5,6],cellregion=1)\n\nConstructor for 3D grid from coordinate arrays.  Boundary region numbers:\n\nlocation number\nsouth 1\neast 2\nnorth 3\nwest 4\nbottom 5\ntop 6\n\nThe keyword arguments allow to overwrite the default region numbers.\n\n\n\n\n\nsimplexgrid(grid2d::ExtendableGrid, coordZ; bot_offset=0,cell_offset=0,top_offset=0, bface_offset=0)\n\nCreate tensor product of 2D  grid and 1D coordinate array.\n\nCellregions and outer facet regions are taken over from 2D grid and added to cell_offset and bface_offset, respectively. Top an bottom facet regions are detected from the cell regions and added to bot_offset resp. top_offset.\n\n\n\n\n\nsimplexgrid(\n    file::String;\n    format\n) -> Union{Nothing, ExtendableGrid}\n\n\nRead grid from file. Currently for pdelib sg and Gmsh formats.\n\n\n\n\n\n","category":"function"},{"location":"gridconstructors/#ExtendableGrids.glue","page":"Grid constructors","title":"ExtendableGrids.glue","text":"c=glue(a,b)\n\nGlue together two vectors a and b resulting in a vector c. They last element  of a shall be equal (up to tol) to the first element of b. The result fulfills length(c)=length(a)+length(b)-1\n\n\n\n\n\nglue(g1,g2;\n     g1regions=1:num_bfaceregions(g1),\n     g2regions=1:num_bfaceregions(g2),\n     interface=0,\n     warnonly = false,\n     tol=1.0e-10,\n     naive=false)\n\nMerge two grids along their common boundary facets. \n\ng1: First grid to be merged\ng2: Second grid to be merged\ng1regions: boundary regions to be used from grid1. Default: all.\ng2regions: boundary regions to be used from grid2. Default: all.\ninterface: if nonzero, create interface region in new grid, otherwise, ignore\nstrict: Assume all bfaces form specfied regions shall be matched, throw error on failure\ntol:  Distance below which two points are seen as identical. Default: 1.0e-10\nnaive: use naive quadratic complexity matching (for checking backward compatibility). Default: false\n\nDeprecated:\n\nbreg: old notation for interface\n\n\n\n\n\n","category":"function"},{"location":"gridconstructors/#Various-special-grids","page":"Grid constructors","title":"Various special grids","text":"","category":"section"},{"location":"gridconstructors/","page":"Grid constructors","title":"Grid constructors","text":"Private = false\nModules = [ExtendableGrids]\nPages = [\"commongrids.jl\"]","category":"page"},{"location":"gridconstructors/#ExtendableGrids.grid_lshape-Tuple{Type{<:Triangle2D}}","page":"Grid constructors","title":"ExtendableGrids.grid_lshape","text":"grid_lshape(::Type{<:Triangle2D}; scale = [1,1], shift = [0,0])\n\nLshape domain\n\n\n\n\n\n","category":"method"},{"location":"gridconstructors/#ExtendableGrids.grid_triangle-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Grid constructors","title":"ExtendableGrids.grid_triangle","text":"grid_triangle(coords::AbstractArray{T,2}) where {T}\n\nGenerates a single triangle with the given coordinates, that should be a 2 x 3 array with the coordinates of the three vertices, e.g. coords = [0.0 0.0; 1.0 0.0; 0.0 1.0]'.\n\n\n\n\n\n","category":"method"},{"location":"gridconstructors/#ExtendableGrids.grid_unitcube-Tuple{Type{<:Hexahedron3D}}","page":"Grid constructors","title":"ExtendableGrids.grid_unitcube","text":"grid_unitcube(EG::Type{<:Hexahedron3D}; scale = [1,1,1], shift = [0,0,0])\n\nUnit cube as one cell with six boundary regions (bottom, front, right, back, left, top)\n\n\n\n\n\n","category":"method"},{"location":"gridconstructors/#ExtendableGrids.grid_unitcube-Tuple{Type{Tetrahedron3D}}","page":"Grid constructors","title":"ExtendableGrids.grid_unitcube","text":"grid_unitcube(::Type{Tetrahedron3D}; scale = [1,1,1], shift = [0,0,0])\n\nUnit cube as six tets with six boundary regions (bottom, front, right, back, left, top)\n\n\n\n\n\n","category":"method"},{"location":"gridconstructors/#ExtendableGrids.grid_unitsquare-Tuple{Type{<:Quadrilateral2D}}","page":"Grid constructors","title":"ExtendableGrids.grid_unitsquare","text":"grid_unitsquare(EG::Type{<:Quadrilateral2D}; scale = [1,1], shift = [0,0])\n\nUnit square as one cell with four boundary regions (bottom, right, top, left)\n\n\n\n\n\n","category":"method"},{"location":"gridconstructors/#ExtendableGrids.grid_unitsquare-Tuple{Type{<:Triangle2D}}","page":"Grid constructors","title":"ExtendableGrids.grid_unitsquare","text":"grid_unitsquare(::Type{<:Triangle2D}; scale = [1,1], shift = [0,0])\n\nUnit square as two triangles with four boundary regions (bottom, right, top, left)\n\n\n\n\n\n","category":"method"},{"location":"gridconstructors/#ExtendableGrids.grid_unitsquare_mixedgeometries-Tuple{}","page":"Grid constructors","title":"ExtendableGrids.grid_unitsquare_mixedgeometries","text":"grid_unitsquare_mixedgeometries()\n\nUnit suqare as mixed triangles and squares with four boundary regions (bottom, right, top, left)\n\n\n\n\n\n","category":"method"},{"location":"gridconstructors/#ExtendableGrids.reference_domain","page":"Grid constructors","title":"ExtendableGrids.reference_domain","text":"    reference_domain(EG::Type{<:AbstractElementGeometry}, T::Type{<:Real} = Float64; scale = [1,1,1], shift = [0,0,0]) -> ExtendableGrid{T,Int32}\n\nGenerates an ExtendableGrid{T,Int32} for the reference domain of the specified Element Geometry. With scale and shift the coordinates can be manipulated.\n\n\n\n\n\n","category":"function"},{"location":"gridconstructors/#ExtendableGrids.ringsector-Tuple{Any, Any}","page":"Grid constructors","title":"ExtendableGrids.ringsector","text":"ringsector(rad,ang; eltype=Triangle2D)\n\nSector of ring or full ring (if  ang[begin]-ang[end]≈2π)\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Adjacency","page":"Adjacency","title":"Adjacency","text":"","category":"section"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"This handles adjacency matrices between entities of polyhedral complexes, e.g. nodes, cells, edges etc.","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"An adjacency is described by an Adjacency matrix, which is a sparse matrix whose entries a 0 or 1. While such a matrix always can be stored as a SparseMatrixCSC, in general this would be a waste of storage.","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"For the general case, it is sufficient to only store the column start indieces and the column entries (row numbers), and to implicitely assume that nonzero entries are 1. This kind of storage is realised in a VariableTargetAdjacency.","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"In many cases, this can be compressed even more, if each column has the same length. In that case, a Matrix is sufficient to store the data. This is the usual base for implementing FEM/FVM assembly, and the interface for the general case should be similar.","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"From these ideas we develop the following interface for an adjacency a.","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"In order to avoid name confusion, we introduce the following notation which  should be consistent with the use in assembly loops.","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"source:  source of adjacency link target:  target of adjacency link","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"E.g. the cell-node adjacency for FEM assembly links  a number of cells with a collection of nodes.  The cells are the sources, and the targets are the nodes. ","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"getindex(a,i,isource) aka a[i,isource]: return i-th target of  source j    numsources(a): overall number of sources, e.g. number of cells    numtargets(a): overall number of targets    numtargets(a,isource): number of targets for source given by isource    numlinks(a): number of links aka nonzero entries of adjacency matrix    show(a): print stuff","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"Further API ideas:","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"Convert between Matrix and Variable target stuff using 0 entries as \"padding\"","category":"page"},{"location":"adjacency/#API","page":"Adjacency","title":"API","text":"","category":"section"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"Modules = [ExtendableGrids]\nPages = [\"adjacency.jl\",\"serialadjacency.jl\"]","category":"page"},{"location":"adjacency/#ExtendableGrids.Adjacency","page":"Adjacency","title":"ExtendableGrids.Adjacency","text":"Adjacency type as union of FixedTargetAdjacency and VariableTargetAdjacency\n\n\n\n\n\n","category":"type"},{"location":"adjacency/#ExtendableGrids.Adjacency-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"Adjacency","title":"ExtendableGrids.Adjacency","text":"Constructors for Adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.FixedTargetAdjacency","page":"Adjacency","title":"ExtendableGrids.FixedTargetAdjacency","text":"mutable struct Array{T, 2} <: DenseArray{T, 2}\n\nUse Matrix to store fixed target adjacency\n\n\n\n\n\n","category":"type"},{"location":"adjacency/#ExtendableGrids.SerialVariableTargetAdjacency-Tuple{}","page":"Adjacency","title":"ExtendableGrids.SerialVariableTargetAdjacency","text":"SerialVariableTargetAdjacency(\n\n) -> SerialVariableTargetAdjacency{Int64}\n\n\nCreate an empty SerialVariableTargetAdjacency with default type\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.SerialVariableTargetAdjacency-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Adjacency","title":"ExtendableGrids.SerialVariableTargetAdjacency","text":"SerialVariableTargetAdjacency(\n    t::Type{T}\n) -> SerialVariableTargetAdjacency\n\n\nCreate an empty SerialVariableTargetAdjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.VariableTargetAdjacency","page":"Adjacency","title":"ExtendableGrids.VariableTargetAdjacency","text":"struct VariableTargetAdjacency{T}\n\nAdjacency struct. Essentially, this is the sparsity pattern of a matrix whose nonzero elements all have the same value in the CSC format.\n\n\n\n\n\n","category":"type"},{"location":"adjacency/#ExtendableGrids.VariableTargetAdjacency-Tuple{}","page":"Adjacency","title":"ExtendableGrids.VariableTargetAdjacency","text":"VariableTargetAdjacency() -> VariableTargetAdjacency{Int64}\n\n\nCreate an empty VariableTargetAdjacency with default type\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.VariableTargetAdjacency-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"Adjacency","title":"ExtendableGrids.VariableTargetAdjacency","text":"VariableTargetAdjacency(\n    m::Array{T, 2}\n) -> VariableTargetAdjacency\n\n\nCreate a VariableTargetAdjacency from Matrix\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.VariableTargetAdjacency-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv<:Integer, Ti<:Integer}","page":"Adjacency","title":"ExtendableGrids.VariableTargetAdjacency","text":"VariableTargetAdjacency(\n    m::SparseArrays.SparseMatrixCSC{Tv<:Integer, Ti<:Integer}\n) -> VariableTargetAdjacency{Ti} where Ti<:Integer\n\n\nCreate variable target adjacency from adjacency matrix\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.VariableTargetAdjacency-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Adjacency","title":"ExtendableGrids.VariableTargetAdjacency","text":"VariableTargetAdjacency(\n    t::Type{T}\n) -> VariableTargetAdjacency\n\n\nCreate an empty VariableTargetAdjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.:==-Union{Tuple{Tb}, Tuple{Ta}, Tuple{SerialVariableTargetAdjacency{Ta}, SerialVariableTargetAdjacency{Tb}}} where {Ta, Tb}","page":"Adjacency","title":"Base.:==","text":"==(a, b)\n\n\nComparison of two adjacencies\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.:==-Union{Tuple{Tb}, Tuple{Ta}, Tuple{VariableTargetAdjacency{Ta}, VariableTargetAdjacency{Tb}}} where {Ta, Tb}","page":"Adjacency","title":"Base.:==","text":"==(a, b)\n\n\nComparison of two adjacencies\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.append!-Tuple{SerialVariableTargetAdjacency, Any}","page":"Adjacency","title":"Base.append!","text":"append!(adj::SerialVariableTargetAdjacency, len) -> Vector\n\n\nAppend a column to adjacency.\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.append!-Tuple{VariableTargetAdjacency, Any}","page":"Adjacency","title":"Base.append!","text":"append!(adj::VariableTargetAdjacency, column) -> Vector\n\n\nAppend a column to adjacency.\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.getindex-Tuple{SerialVariableTargetAdjacency, Any, Any}","page":"Adjacency","title":"Base.getindex","text":"getindex(\n    adj::SerialVariableTargetAdjacency,\n    i,\n    isource\n) -> Any\n\n\nAccess adjacency as if it is a 2D Array\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.getindex-Tuple{VariableTargetAdjacency, Any, Any}","page":"Adjacency","title":"Base.getindex","text":"getindex(adj::VariableTargetAdjacency, i, isource) -> Any\n\n\nAccess adjacency as if it is a 2D Array\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.show-Tuple{IO, SerialVariableTargetAdjacency}","page":"Adjacency","title":"Base.show","text":"show(io::IO, adj::SerialVariableTargetAdjacency)\n\n\nShow adjacency (in trasposed form; preliminary)\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.show-Tuple{IO, VariableTargetAdjacency}","page":"Adjacency","title":"Base.show","text":"show(io::IO, adj::VariableTargetAdjacency)\n\n\nShow adjacency (in trasposed form; preliminary)\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.asparse-Tuple{Matrix}","page":"Adjacency","title":"ExtendableGrids.asparse","text":"asparse(a::Matrix) -> SparseArrays.SparseMatrixCSC{Int64}\n\n\nCreate sparse incidence matrix from adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.asparse-Tuple{VariableTargetAdjacency}","page":"Adjacency","title":"ExtendableGrids.asparse","text":"asparse(\n    a::VariableTargetAdjacency\n) -> SparseArrays.SparseMatrixCSC{Int64}\n\n\nCreate sparse incidence matrix from adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.atranspose-Union{Tuple{Adjacency{T}}, Tuple{T}} where T","page":"Adjacency","title":"ExtendableGrids.atranspose","text":"Transpose adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.makevar-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"Adjacency","title":"ExtendableGrids.makevar","text":"makevar(a::Array{T, 2}) -> VariableTargetAdjacency\n\n\nTurn fixed target adjacency into variable target adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.max_num_targets_per_source-Tuple{Matrix}","page":"Adjacency","title":"ExtendableGrids.max_num_targets_per_source","text":"max_num_targets_per_source(adj::Matrix) -> Int64\n\n\nMaximum number of targets per source\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.max_num_targets_per_source-Tuple{SerialVariableTargetAdjacency}","page":"Adjacency","title":"ExtendableGrids.max_num_targets_per_source","text":"max_num_targets_per_source(\n    adj::SerialVariableTargetAdjacency\n) -> Any\n\n\nMaximum number of targets per source\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.max_num_targets_per_source-Tuple{VariableTargetAdjacency}","page":"Adjacency","title":"ExtendableGrids.max_num_targets_per_source","text":"max_num_targets_per_source(\n    adj::VariableTargetAdjacency\n) -> Any\n\n\nMaximum number of targets per source\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_links-Tuple{Matrix}","page":"Adjacency","title":"ExtendableGrids.num_links","text":"num_links(adj::Matrix) -> Int64\n\n\nNumber of entries\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_links-Tuple{VariableTargetAdjacency}","page":"Adjacency","title":"ExtendableGrids.num_links","text":"num_links(adj::VariableTargetAdjacency) -> Int64\n\n\nNumber of links\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_sources-Tuple{Matrix}","page":"Adjacency","title":"ExtendableGrids.num_sources","text":"num_sources(adj::Matrix) -> Int64\n\n\nNumber of sources in adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_sources-Tuple{SerialVariableTargetAdjacency}","page":"Adjacency","title":"ExtendableGrids.num_sources","text":"num_sources(adj::SerialVariableTargetAdjacency) -> Int64\n\n\nNumber of sources in adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_sources-Tuple{VariableTargetAdjacency}","page":"Adjacency","title":"ExtendableGrids.num_sources","text":"num_sources(adj::VariableTargetAdjacency) -> Int64\n\n\nNumber of sources in adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_targets-Tuple{Matrix, Any}","page":"Adjacency","title":"ExtendableGrids.num_targets","text":"num_targets(adj::Matrix, isource) -> Int64\n\n\nNumber of targets per source if adjacency is a matrix\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_targets-Tuple{Matrix}","page":"Adjacency","title":"ExtendableGrids.num_targets","text":"num_targets(adj::Matrix) -> Any\n\n\nOverall number of targets \n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_targets-Tuple{SerialVariableTargetAdjacency, Any}","page":"Adjacency","title":"ExtendableGrids.num_targets","text":"num_targets(\n    adj::SerialVariableTargetAdjacency,\n    isource\n) -> Any\n\n\nNumber of targets for given source\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_targets-Tuple{VariableTargetAdjacency, Any}","page":"Adjacency","title":"ExtendableGrids.num_targets","text":"num_targets(adj::VariableTargetAdjacency, isource) -> Any\n\n\nNumber of targets for given source\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_targets-Tuple{VariableTargetAdjacency}","page":"Adjacency","title":"ExtendableGrids.num_targets","text":"num_targets(adj::VariableTargetAdjacency) -> Any\n\n\nNumber of targeta\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.tryfix-Union{Tuple{Adjacency{T}}, Tuple{T}} where T","page":"Adjacency","title":"ExtendableGrids.tryfix","text":"tryfix(\n    a::Union{Array{T, 2}, VariableTargetAdjacency{T}}\n) -> Any\n\n\nTry to turn variable target adjacency into fixed target adjacency\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#Shape-specifications","page":"Shape specifications","title":"Shape specifications","text":"","category":"section"},{"location":"shape_specs/#API","page":"Shape specifications","title":"API","text":"","category":"section"},{"location":"shape_specs/","page":"Shape specifications","title":"Shape specifications","text":"Modules = [ExtendableGrids]\nPages = [\"shape_specs.jl\"]","category":"page"},{"location":"shape_specs/#ExtendableGrids.facetype_of_cellface-Tuple{Type{<:AbstractElementGeometry1D}, Any}","page":"Shape specifications","title":"ExtendableGrids.facetype_of_cellface","text":"facetype_of_cellface(_, k)\n\n\nGeometries of faces of 1D edge\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.facetype_of_cellface-Tuple{Type{<:Hexahedron3D}, Any}","page":"Shape specifications","title":"ExtendableGrids.facetype_of_cellface","text":"facetype_of_cellface(_, k)\n\n\nGeometries of faces of 3D hexahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.facetype_of_cellface-Tuple{Type{<:Parallelepiped3D}, Any}","page":"Shape specifications","title":"ExtendableGrids.facetype_of_cellface","text":"facetype_of_cellface(_, k)\n\n\nGeometries of faces of 3D parallelepiped\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.facetype_of_cellface-Tuple{Type{<:Quadrilateral2D}, Any}","page":"Shape specifications","title":"ExtendableGrids.facetype_of_cellface","text":"facetype_of_cellface(_, k)\n\n\nGeometries of faces of 2D quadrilateral\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.facetype_of_cellface-Tuple{Type{<:Tetrahedron3D}, Any}","page":"Shape specifications","title":"ExtendableGrids.facetype_of_cellface","text":"facetype_of_cellface(_, k)\n\n\nGeometries of faces of 3D tetrahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.facetype_of_cellface-Tuple{Type{<:Triangle2D}, Any}","page":"Shape specifications","title":"ExtendableGrids.facetype_of_cellface","text":"facetype_of_cellface(_, k)\n\n\nGeometries of faces of 2D triangle\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_celledgenodes-Tuple{Type{<:AbstractElementGeometry1D}}","page":"Shape specifications","title":"ExtendableGrids.local_celledgenodes","text":"local_celledgenodes(_)\n\n\nCell-edge node numbering for 1D edge\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_celledgenodes-Tuple{Type{<:Hexahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.local_celledgenodes","text":"local_celledgenodes(_)\n\n\nCell-edge node numbering for 3D hexahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_celledgenodes-Tuple{Type{<:Quadrilateral2D}}","page":"Shape specifications","title":"ExtendableGrids.local_celledgenodes","text":"local_celledgenodes(_)\n\n\nCell-edge node numbering for 2D quadrilateral\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_celledgenodes-Tuple{Type{<:Tetrahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.local_celledgenodes","text":"local_celledgenodes(_)\n\n\nCell-edge node numbering for 3D tetrahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_celledgenodes-Tuple{Type{<:Triangle2D}}","page":"Shape specifications","title":"ExtendableGrids.local_celledgenodes","text":"local_celledgenodes(_)\n\n\nCell-edge node numbering for 2D triangle\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_celledgenodes-Tuple{Type{Vertex0D}}","page":"Shape specifications","title":"ExtendableGrids.local_celledgenodes","text":"local_celledgenodes(_)\n\n\nCell-edge node numbering for 1D edge\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_cellfacenodes-Tuple{Type{<:AbstractElementGeometry1D}}","page":"Shape specifications","title":"ExtendableGrids.local_cellfacenodes","text":"local_cellfacenodes(_)\n\n\nCell-face node numbering for 1D edge\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_cellfacenodes-Tuple{Type{<:Hexahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.local_cellfacenodes","text":"local_cellfacenodes(_)\n\n\nCell-face node numbering for 3D hexahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_cellfacenodes-Tuple{Type{<:Quadrilateral2D}}","page":"Shape specifications","title":"ExtendableGrids.local_cellfacenodes","text":"local_cellfacenodes(_)\n\n\nCell-face node numbering for 2D quadrilateral\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_cellfacenodes-Tuple{Type{<:Tetrahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.local_cellfacenodes","text":"local_cellfacenodes(_)\n\n\nCell-face node numbering for 3D tetrahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_cellfacenodes-Tuple{Type{<:Triangle2D}}","page":"Shape specifications","title":"ExtendableGrids.local_cellfacenodes","text":"local_cellfacenodes(_)\n\n\nCell-face node numbering for 2D triangle\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_edges-Tuple{ExtendableGrid}","page":"Shape specifications","title":"ExtendableGrids.num_edges","text":"num_edges(grid)\n\n\nNumber of edges in grid.\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_edges-Tuple{Type{<:AbstractElementGeometry0D}}","page":"Shape specifications","title":"ExtendableGrids.num_edges","text":"num_edges(_)\n\n\nNumber of edges of 0D vertex\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_edges-Tuple{Type{<:AbstractElementGeometry1D}}","page":"Shape specifications","title":"ExtendableGrids.num_edges","text":"num_edges(_)\n\n\nNumber of edges for 1D edge\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_edges-Tuple{Type{<:Quadrilateral2D}}","page":"Shape specifications","title":"ExtendableGrids.num_edges","text":"num_edges(_)\n\n\nNumber of edges in 2D quadrilateral\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_edges-Tuple{Type{<:Tetrahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.num_edges","text":"num_edges(_)\n\n\nNumber of edges in 3D tetrahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_edges-Tuple{Type{<:Triangle2D}}","page":"Shape specifications","title":"ExtendableGrids.num_edges","text":"num_edges(_)\n\n\nNumber of edges in 2D triangle\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_edges-Tuple{Type{Edge1D}}","page":"Shape specifications","title":"ExtendableGrids.num_edges","text":"num_edges(_)\n\n\nNumber of edges of 1D edge\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_faces-Tuple{Type{<:AbstractElementGeometry0D}}","page":"Shape specifications","title":"ExtendableGrids.num_faces","text":"num_faces(_)\n\n\nNumber of faces of 0D vertex\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_faces-Tuple{Type{<:AbstractElementGeometry1D}}","page":"Shape specifications","title":"ExtendableGrids.num_faces","text":"num_faces(_)\n\n\nNumber of faces for 1D edge\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_faces-Tuple{Type{<:Quadrilateral2D}}","page":"Shape specifications","title":"ExtendableGrids.num_faces","text":"num_faces(_)\n\n\nNumber of faces in 2D quadrilateral\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_faces-Tuple{Type{<:Tetrahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.num_faces","text":"num_faces(_)\n\n\nNumber of faces in 3D tetrahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_faces-Tuple{Type{<:Triangle2D}}","page":"Shape specifications","title":"ExtendableGrids.num_faces","text":"num_faces(_)\n\n\nNumber of faces in 2D triangle\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_nodes-Tuple{Type{<:AbstractElementGeometry0D}}","page":"Shape specifications","title":"ExtendableGrids.num_nodes","text":"num_nodes(_)\n\n\nNumber of nodes of 0D vertex\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_nodes-Tuple{Type{<:AbstractElementGeometry1D}}","page":"Shape specifications","title":"ExtendableGrids.num_nodes","text":"num_nodes(_)\n\n\nNumber of nodes for 1D edge\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_nodes-Tuple{Type{<:Hexahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.num_nodes","text":"num_nodes(_)\n\n\nNumber of nodes in 3D hexahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_nodes-Tuple{Type{<:Quadrilateral2D}}","page":"Shape specifications","title":"ExtendableGrids.num_nodes","text":"num_nodes(_)\n\n\nNumber of nodes in 2D quadrilateral\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_nodes-Tuple{Type{<:Tetrahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.num_nodes","text":"num_nodes(_)\n\n\nNumber of nodes in 3D tetrahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_nodes-Tuple{Type{<:Triangle2D}}","page":"Shape specifications","title":"ExtendableGrids.num_nodes","text":"num_nodes(_)\n\n\nNumber of nodes in 2D triangle\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.refcoords_for_geometry-Tuple{Type{<:AbstractElementGeometry0D}}","page":"Shape specifications","title":"ExtendableGrids.refcoords_for_geometry","text":"refcoords_for_geometry(_)\n\n\nCoordinates of reference geometry of 0D vertex\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.refcoords_for_geometry-Tuple{Type{<:AbstractElementGeometry1D}}","page":"Shape specifications","title":"ExtendableGrids.refcoords_for_geometry","text":"refcoords_for_geometry(_)\n\n\nCoordinates of reference geometry of 1D edge\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.refcoords_for_geometry-Tuple{Type{<:Hexahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.refcoords_for_geometry","text":"refcoords_for_geometry(_)\n\n\nCoordinates of reference geometry of 3D hexahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.refcoords_for_geometry-Tuple{Type{<:Quadrilateral2D}}","page":"Shape specifications","title":"ExtendableGrids.refcoords_for_geometry","text":"refcoords_for_geometry(_)\n\n\nCoordinates of reference geometry of 2D quadrilateral\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.refcoords_for_geometry-Tuple{Type{<:Tetrahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.refcoords_for_geometry","text":"refcoords_for_geometry(_)\n\n\nCoordinates of reference geometry of 3D tetrahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.refcoords_for_geometry-Tuple{Type{<:Triangle2D}}","page":"Shape specifications","title":"ExtendableGrids.refcoords_for_geometry","text":"refcoords_for_geometry(_)\n\n\nCoordinates of reference geometry of 2D triangle\n\n\n\n\n\n","category":"method"},{"location":"partitioning/#Grid-partitioning","page":"Grid partitioning","title":"Grid partitioning","text":"","category":"section"},{"location":"partitioning/","page":"Grid partitioning","title":"Grid partitioning","text":"compat: Compat\nGrid partitioning is an experimental feature. Breaking changes in this realm may occur with minor version updates.","category":"page"},{"location":"partitioning/#API-calls","page":"Grid partitioning","title":"API calls","text":"","category":"section"},{"location":"partitioning/","page":"Grid partitioning","title":"Grid partitioning","text":"partition\nnum_pcolors\nnum_partitions\nnum_partitions_per_color\nnum_cells_per_color\npcolors\npcolor_partitions\npartition_cells\npartition_nodes\ncheck_partitioning","category":"page"},{"location":"partitioning/#ExtendableGrids.partition","page":"Grid partitioning","title":"ExtendableGrids.partition","text":"partition(grid, alg::AbstractPartitioningAlgorithm)\n\nPartition grid according to alg, such that the neigborhood graph of partitions is colored in such a way, that all partitions with  a given color can be worked on in parallel.\n\n\n\n\n\n","category":"function"},{"location":"partitioning/#ExtendableGrids.num_pcolors","page":"Grid partitioning","title":"ExtendableGrids.num_pcolors","text":"num_pcolors(grid)\n\n\nReturn number of partition colors.\n\n\n\n\n\n","category":"function"},{"location":"partitioning/#ExtendableGrids.num_partitions","page":"Grid partitioning","title":"ExtendableGrids.num_partitions","text":"num_partitions(grid)\n\n\nReturn number of partitions.\n\n\n\n\n\n","category":"function"},{"location":"partitioning/#ExtendableGrids.num_partitions_per_color","page":"Grid partitioning","title":"ExtendableGrids.num_partitions_per_color","text":"num_partitions_per_color(grid)\n\n\nReturn a vector containing the number of partitions for each of the colors of the grid partitioning.\n\n\n\n\n\n","category":"function"},{"location":"partitioning/#ExtendableGrids.num_cells_per_color","page":"Grid partitioning","title":"ExtendableGrids.num_cells_per_color","text":"num_cells_per_color(grid)\n\n\nReturn a vector containing the number of cells for each of the colors of the grid partitioning.\n\n\n\n\n\n","category":"function"},{"location":"partitioning/#ExtendableGrids.pcolors","page":"Grid partitioning","title":"ExtendableGrids.pcolors","text":"pcolors(grid)\n\n\nReturn range of all pcolors.\n\n\n\n\n\n","category":"function"},{"location":"partitioning/#ExtendableGrids.pcolor_partitions","page":"Grid partitioning","title":"ExtendableGrids.pcolor_partitions","text":"pcolor_partitions(grid, color)\n\n\nReturn range of partitions for given pcolor.\n\n\n\n\n\n","category":"function"},{"location":"partitioning/#ExtendableGrids.partition_cells","page":"Grid partitioning","title":"ExtendableGrids.partition_cells","text":"partition_cells(grid, part)\n\n\nReturn range of cells belonging to a given partition.\n\n\n\n\n\n","category":"function"},{"location":"partitioning/#ExtendableGrids.partition_nodes","page":"Grid partitioning","title":"ExtendableGrids.partition_nodes","text":"partition_nodes(grid, part)\n\n\nReturn range of nodes belonging to a given partition.\n\n\n\n\n\n","category":"function"},{"location":"partitioning/#ExtendableGrids.check_partitioning","page":"Grid partitioning","title":"ExtendableGrids.check_partitioning","text":"check_partitioning(grid; \n                   verbose=true, \n                   cellpartonly=false)\n\nCheck correctness of cell partitioning, necessesary for parallel assembly:\n\nCheck if every node belongs to one of the cell partitions\nCheck if no node belongs to two cell partitions of the same color at once\n\nIf cellpartonly==false check correctness of node partitioning necessary for parallel sparse matrix multiplication and ILU preconditioning\n\nCheck if no node belongs to two node partitions of the same color at once\nCheck if no node is a neighbor of nodes from two node partitions of the same color\n\n\n\n\n\n","category":"function"},{"location":"partitioning/#Partitioning-algorithms","page":"Grid partitioning","title":"Partitioning algorithms","text":"","category":"section"},{"location":"partitioning/","page":"Grid partitioning","title":"Grid partitioning","text":"AbstractPartitioningAlgorithm\nTrivialPartitioning\nPlainMetisPartitioning\nRecursiveMetisPartitioning","category":"page"},{"location":"partitioning/#ExtendableGrids.AbstractPartitioningAlgorithm","page":"Grid partitioning","title":"ExtendableGrids.AbstractPartitioningAlgorithm","text":"abstract type AbstractPartitioningAlgorithm\n\nAbstract super type for partitioning algorithms\n\n\n\n\n\n","category":"type"},{"location":"partitioning/#ExtendableGrids.TrivialPartitioning","page":"Grid partitioning","title":"ExtendableGrids.TrivialPartitioning","text":"struct TrivialPartitioning <: AbstractPartitioningAlgorithm\n\nTrivial partitioning: all grid cells belong to single partition number 1.\n\n\n\n\n\n","category":"type"},{"location":"partitioning/#ExtendableGrids.PlainMetisPartitioning","page":"Grid partitioning","title":"ExtendableGrids.PlainMetisPartitioning","text":"struct PlainMetisPartitioning <: AbstractPartitioningAlgorithm\n\nSubdivide grid into npart partitions using Metis.partition and color the resulting partition neigborhood graph. This requires to import Metis.jl in order to trigger the corresponding extension.\n\nwarning: Warning\nThis algorithm is unreliable with respect to the induced node partitioning, see induce_node_partitioning!. Check the result with check_partitioning before use.    \n\nParameters: \n\nnpart::Int64: Number of partitions (default: 20)\npartition_nodes::Bool: Induce node partioning (default: true)\nkeep_nodepermutation::Bool: Keep node permutation vector (default: true)\n\n\n\n\n\n","category":"type"},{"location":"partitioning/#ExtendableGrids.RecursiveMetisPartitioning","page":"Grid partitioning","title":"ExtendableGrids.RecursiveMetisPartitioning","text":"struct RecursiveMetisPartitioning <: AbstractPartitioningAlgorithm\n\nSubdivide grid into npart partitions using Metis.partition and calculate cell separators from this partitioning. The initial partitions  get pcolor 1, and the separator gets pcolor 2. This is continued recursively with partitioning of the separator.  \n\nwarning: Warning\nThis algorithm is unreliable with respect to the induced node partitioning, see induce_node_partitioning!. Check the result with check_partitioning before use.    \n\nParameters: \n\nnpart::Int64: Number of level 0 partitions (default: 4)\nmaxdepth::Int64: Recursion depth (default: 1)\nseparatorwidth::Int64: Separator width  (default: 2)\npartition_nodes::Bool: Induce node partioning (default: true)\nkeep_nodepermutation::Bool: Keep node permutation vector (default: true)\n\n\n\n\n\n","category":"type"},{"location":"partitioning/#Key-types-for-grid-access","page":"Grid partitioning","title":"Key types for grid access","text":"","category":"section"},{"location":"partitioning/","page":"Grid partitioning","title":"Grid partitioning","text":"PColorPartitions \nPartitionCells\nPartitionNodes\nNodePermutation","category":"page"},{"location":"partitioning/#ExtendableGrids.PColorPartitions","page":"Grid partitioning","title":"ExtendableGrids.PColorPartitions","text":"abstract type PColorPartitions <: AbstractGridIntegerArray1D\n\nKey type describing colors of partitions. These correspond to  a coloring of the neigborhood graphs of partitions such that  operations (e.g. FEM assembly) on partitions of a given color can  be performed in parallel.\n\ngrid[PColorPartitions] returns an integer vector describing  the partition colors (\"pcolors\") of a grid.  Let p=grid[PColorPartitions]. Then all partitions with numbers i ∈ p[c]:p[c+1]-1  have \"color\" c. \n\n\n\n\n\n","category":"type"},{"location":"partitioning/#ExtendableGrids.PartitionCells","page":"Grid partitioning","title":"ExtendableGrids.PartitionCells","text":"abstract type PartitionCells <: AbstractGridIntegerArray1D\n\nKey type describing the cells of a given partition.\n\ngrid[PartitionCells] returns an integer vector describing  the cells of a partition  given by its number. Let pc=grid[PartitionCells]. Then all cells with index i ∈ pc[p]:pc[p+1]-1  belong to partition p.\n\n\n\n\n\n","category":"type"},{"location":"partitioning/#ExtendableGrids.PartitionNodes","page":"Grid partitioning","title":"ExtendableGrids.PartitionNodes","text":"abstract type PartitionNodes <: AbstractGridIntegerArray1D\n\nKey type describing the nodes of a given partition.\n\ngrid[PartitionNodes] returns an integer vector describing  the nodes of a partition  given by its number. Let pn=grid[PartitionNodes]. Then all nodes with index i ∈ pn[p]:pn[p+1]-1  belong to partition p.\n\n\n\n\n\n","category":"type"},{"location":"partitioning/#ExtendableGrids.NodePermutation","page":"Grid partitioning","title":"ExtendableGrids.NodePermutation","text":"abstract type NodePermutation <: AbstractGridIntegerArray1D\n\nKey type describing the permutation of the nodes of a partitioned grid with respect  to the unpartitioned origin.\n\nIf pgrid is the partitioned grid and grid is the unpartitioned origin, then \n\npgrid[Coordinates][:,pgrid[NodePermutation]]==grid[Coordinates]\n\n\n\n\n\n","category":"type"},{"location":"partitioning/#Internal-API","page":"Grid partitioning","title":"Internal API","text":"","category":"section"},{"location":"partitioning/","page":"Grid partitioning","title":"Grid partitioning","text":"ExtendableGrids.trivial_partitioning!\nExtendableGrids.instantiate(grid::ExtendableGrid, ::Type{PColorPartitions})\nExtendableGrids.instantiate(grid::ExtendableGrid, ::Type{PartitionCells})\nExtendableGrids.instantiate(grid::ExtendableGrid, ::Type{PartitionNodes})\nExtendableGrids.partgraph\nExtendableGrids.reorder_cells\nExtendableGrids.induce_node_partitioning!","category":"page"},{"location":"partitioning/#ExtendableGrids.trivial_partitioning!","page":"Grid partitioning","title":"ExtendableGrids.trivial_partitioning!","text":"trivial_partitioning!(grid)\n\n\n(internal) Create trivial partitioning: the whole grid is partition #1 with just one color.\n\n\n\n\n\n","category":"function"},{"location":"partitioning/#ExtendableGrids.instantiate-Tuple{ExtendableGrid, Type{PColorPartitions}}","page":"Grid partitioning","title":"ExtendableGrids.instantiate","text":"instantiate(grid::ExtendableGrid, ::Type{PColorPartitions})\n\nIf not given otherwise, instantiate partition data with trivial partitioning.\n\n\n\n\n\n","category":"method"},{"location":"partitioning/#ExtendableGrids.instantiate-Tuple{ExtendableGrid, Type{PartitionCells}}","page":"Grid partitioning","title":"ExtendableGrids.instantiate","text":"instantiate(grid::ExtendableGrid, ::Type{PColorPartitions})\n\nIf not given otherwise, instantiate partition data with trivial partitioning.\n\n\n\n\n\n","category":"method"},{"location":"partitioning/#ExtendableGrids.instantiate-Tuple{ExtendableGrid, Type{PartitionNodes}}","page":"Grid partitioning","title":"ExtendableGrids.instantiate","text":"instantiate(grid::ExtendableGrid, ::Type{PartitionNodes})\n\nIf not given otherwise, instantiate partition data with trivial partitioning.\n\n\n\n\n\n","category":"method"},{"location":"partitioning/#ExtendableGrids.partgraph","page":"Grid partitioning","title":"ExtendableGrids.partgraph","text":"partgraph(cellpartitions, ncellpartitions, cellcelladj)\n\n\n(internal) Create neigbourhood graph for given partitioning.\n\n\n\n\n\n","category":"function"},{"location":"partitioning/#ExtendableGrids.reorder_cells","page":"Grid partitioning","title":"ExtendableGrids.reorder_cells","text":"reorder_cells(\n    grid,\n    cellpartitions,\n    ncellpartitions,\n    colpart\n)\n\n\n(internal) Create cell permutation such that  all cells belonging to one partition are contiguous and reorder return grid with reordered cells.\n\n\n\n\n\n","category":"function"},{"location":"partitioning/#ExtendableGrids.induce_node_partitioning!","page":"Grid partitioning","title":"ExtendableGrids.induce_node_partitioning!","text":"induce_node_partitioning!(\n    grid,\n    nc;\n    trivial,\n    keep_nodepermutation\n)\n\n\n(internal) Induce node partitioning from cell partitioning of grid.\n\nNode partitioning should support parallel matrix-vector products with SparseMatrixCSC. The current algorithm assumes that nodes get the partition number from the partition numbers of the cells having this node in common. If these are differnt, the highest number is taken.\n\nThis algorithm does not always fulfill the following condition (checked among others by check_partitioning with cellpartonly=false): There is no node which is neigbour of nodes from two different partition with the same color.\n\n\n\n\n\n","category":"function"},{"location":"tdict/#The-TDict-interface-pattern","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Here we describe the idea behind the data structure used in this package. TDict means: extendable containers with type stable content access and lazy content creation via the Julia type system.","category":"page"},{"location":"tdict/#Problem-to-be-addressed","page":"The TDict interface pattern","title":"Problem to be addressed","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"In certain contexts it is desirable to use containers with core components which are user extendable and allow for type stable component acces. Moreover, some components are necessary on demand only, so they should be created lazily. Furthermore, there should be a kind of safety protocol which prevents errors from typos in component names etc.","category":"page"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Julia default data structures do not provide these properties.","category":"page"},{"location":"tdict/#struct","page":"The TDict interface pattern","title":"struct","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Julia structs with proper field type annotations guarantee type stability\nJulia structs are not extendable, fields and their types are fixed upon definition\nIf we don't fix types of struct fields they become Any and a source  for type instability\nThe situation could be fixed if getfield could be overloaded but it cant't","category":"page"},{"location":"tdict/#Dict","page":"The TDict interface pattern","title":"Dict","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Plain Dicts with flexible value types are a source of type instability\nDicts with strings as keys needs a meta protocol to handle semantics of keys which at the end probably hinges on string comparison which will make things slow\nDicts with symbols as keys still need this meta protocol\nSame for the implementation of a lazy evaluation protocol\nIf a dict contains components of different types, component access will not be typestable","category":"page"},{"location":"tdict/#Proposed-solution:","page":"The TDict interface pattern","title":"Proposed solution:","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Harness the power of the Julia type system: ","category":"page"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Use a struct containing a  Dict with DataType as keys. Every key is a type.\nUse type hierarchies to manage different  value classes\nUse the type system to dispatch between  getindex/setindex! methods for keys\nExtension requires declaring new types, keys can be only existing types almost removing typos as sources for errors\nLazy extension is managed bye an  instantiate method called by getindex if necessary\nComponent access is made type stable by type dispatchedgetindex methods\nComponent insertion is made safe by having  setindex!  calling a veryform method","category":"page"},{"location":"tdict/#Pros","page":"The TDict interface pattern","title":"Pros","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"See above ...","category":"page"},{"location":"tdict/#Cons","page":"The TDict interface pattern","title":"Cons","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Implemented using a Dict, so access is inherently slower than access to a component of a struct. Therefore it is not well suited for inner loops.","category":"page"},{"location":"extendablegrid/#Extendable-grid","page":"Extendable grid","title":"Extendable grid","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"An ExtendableGrid in form of a dictionary with types as keys and type stable value access. This means that grid components are accessed as dict entries, e.g. grid[Coordinates] . The rationale of this approach is explained here.","category":"page"},{"location":"extendablegrid/#Notations","page":"Extendable grid","title":"Notations","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"A grid is assumed to be a subset of components of a polyhedral complex in d-dimensional space. We distinguish the following element classes characterized by their dimension:","category":"page"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Element class Meaning\nNode 0-dimensional node\nEdge 1-dimensional line connecting two neigboring nodes\nFace codimension 1 object separating a cell from outer space or neigboring cell\nCell codimension 0 object\nBFace Face situated at inner or domain boundary\nRegion number to be used to characterize subdomains, contacts etc.","category":"page"},{"location":"extendablegrid/#Grid-components","page":"Extendable grid","title":"Grid components","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Grid components are accessed like Dict entries, the keys must be subtypes of AbstractGridComponent.","category":"page"},{"location":"extendablegrid/#Basic-set-of-grid-components","page":"Extendable grid","title":"Basic set of grid components","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Upon construction, an ExtendableGrid needs to be provided with the basic set of grid components denoted by the following component type keys:","category":"page"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Component type key Meaning\nCoordinates Coordinates of the vertices of the grid cells\nCellNodes Adjacency describing the nodes of grid cell\nCellGeometries Abstract array of subtypes of AbstractElementGeometry describing the geometry of each cell\nCellRegions Abstract array of integers describing region numbers\nBFaceNodes Adjacency structure describing the nodes corresponding to each grid boundary face\nBFaceGeometries Abstract array of subtypes of AbstractElementGeometry describing the geometry of each boundary face\nBFaceRegions Abstract array of integers describig region numbers\nCoordinateSystem Abstract type describing the coordinate system to be used","category":"page"},{"location":"extendablegrid/#Hierarchy-of-component-type-keys","page":"Extendable grid","title":"Hierarchy of component type keys","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"The list of components can be printed using the gridcomponents method.","category":"page"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"using ExtendableGrids # hide\ngridcomponents() #hide","category":"page"},{"location":"extendablegrid/#Additional-components","page":"Extendable grid","title":"Additional components","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Additional components can be added by defining  a subtype of AbstractGridComponent or a fitting subtype thereof, and assigning the value to the corresponding Dict entry:","category":"page"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"using ExtendableGrids # hide\ng=simplexgrid([1,2,3,4.0])\nabstract type MyComponent <: AbstractGridComponent end\ng[MyComponent]=13\nshow(g)","category":"page"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Alternatively, component creation can be perfomed lazily. For this purpose one needs to define an instantiate method:","category":"page"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"using ExtendableGrids # hide\nabstract type NodeCells <: AbstractGridAdjacency end\nExtendableGrids.instantiate(grid, ::Type{NodeCells})=atranspose(grid[CellNodes])\ng=simplexgrid([1,2,3,4.0])\nshow(g[NodeCells])","category":"page"},{"location":"extendablegrid/#Grid-API","page":"Extendable grid","title":"Grid API","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Modules = [ExtendableGrids]\nPages = [\"extendablegrid.jl\"]","category":"page"},{"location":"extendablegrid/#ExtendableGrids.ElementInfo","page":"Extendable grid","title":"ExtendableGrids.ElementInfo","text":"const ElementInfo{T}=Union{Vector{T},VectorOfConstants{T}}\n\nUnion type for element information arrays. If all elements have the same information, it can be stored in an economical form as a VectorOfConstants.\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractElementGeometries","page":"Extendable grid","title":"ExtendableGrids.AbstractElementGeometries","text":"abstract type AbstractElementGeometries <: AbstractGridComponent\n\nArray of element geometry information. \n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractElementRegions","page":"Extendable grid","title":"ExtendableGrids.AbstractElementRegions","text":"abstract type AbstractElementRegions <: AbstractGridComponent\n\nArray of element region number information. \n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridAdjacency","page":"Extendable grid","title":"ExtendableGrids.AbstractGridAdjacency","text":"abstract type AbstractGridAdjacency <: AbstractGridComponent\n\nAny kind of adjacency between grid components\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridComponent","page":"Extendable grid","title":"ExtendableGrids.AbstractGridComponent","text":"abstract type AbstractGridComponent <: AbstractExtendableGridApexType\n\nApex type for grid components.\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridFloatArray1D","page":"Extendable grid","title":"ExtendableGrids.AbstractGridFloatArray1D","text":"abstract type AbstractGridFloatArray1D <: AbstractGridComponent\n\n1D Array of floating point data\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridFloatArray2D","page":"Extendable grid","title":"ExtendableGrids.AbstractGridFloatArray2D","text":"abstract type AbstractGridFloatArray2D <: AbstractGridComponent\n\n2D Array of floating point data\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridFloatConstant","page":"Extendable grid","title":"ExtendableGrids.AbstractGridFloatConstant","text":"abstract type AbstractGridFloatConstant <: AbstractGridComponent\n\nFloating point number\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridIntegerArray1D","page":"Extendable grid","title":"ExtendableGrids.AbstractGridIntegerArray1D","text":"abstract type AbstractGridIntegerArray1D <: AbstractGridComponent\n\n1D Array of interger data\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridIntegerArray2D","page":"Extendable grid","title":"ExtendableGrids.AbstractGridIntegerArray2D","text":"abstract type AbstractGridIntegerArray2D <: AbstractGridComponent\n\n2D Array of integer data\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridIntegerConstant","page":"Extendable grid","title":"ExtendableGrids.AbstractGridIntegerConstant","text":"abstract type AbstractGridIntegerConstant <: AbstractGridComponent\n\nInteger number\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.BEdgeRegions","page":"Extendable grid","title":"ExtendableGrids.BEdgeRegions","text":"abstract type BEdgeRegions <: AbstractElementRegions\n\nBoundary edge region number per boundary edge\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.BFaceGeometries","page":"Extendable grid","title":"ExtendableGrids.BFaceGeometries","text":"Description of boundary face geometries\n\nabstract type BFaceGeometries <: AbstractElementGeometries\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.BFaceNodes","page":"Extendable grid","title":"ExtendableGrids.BFaceNodes","text":"abstract type BFaceNodes <: AbstractGridAdjacency\n\nAdjacency describing nodes per grid boundary face\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.BFaceRegions","page":"Extendable grid","title":"ExtendableGrids.BFaceRegions","text":"abstract type BFaceRegions <: AbstractElementRegions\n\nBoundary region number per boundary face\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.CellGeometries","page":"Extendable grid","title":"ExtendableGrids.CellGeometries","text":"abstract type CellGeometries <: AbstractElementGeometries\n\nDescription of cell geometries\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.CellNodes","page":"Extendable grid","title":"ExtendableGrids.CellNodes","text":"abstract type CellNodes <: AbstractGridAdjacency\n\nAdjacency describing nodes per grid cell\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.CellRegions","page":"Extendable grid","title":"ExtendableGrids.CellRegions","text":"abstract type CellRegions <: AbstractElementRegions\n\nCell region number per cell\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.CoordinateSystem","page":"Extendable grid","title":"ExtendableGrids.CoordinateSystem","text":"abstract type CoordinateSystem <: AbstractGridComponent\n\nCoordinate system\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.Coordinates","page":"Extendable grid","title":"ExtendableGrids.Coordinates","text":"abstract type Coordinates <: AbstractGridFloatArray2D\n\nNode coordinates\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.ExtendableGrid","page":"Extendable grid","title":"ExtendableGrids.ExtendableGrid","text":"mutable struct ExtendableGrid{Tc, Ti}\n\nGrid type wrapping Dict\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.NumBEdgeRegions","page":"Extendable grid","title":"ExtendableGrids.NumBEdgeRegions","text":"abstract type NumBEdgeRegions <: ExtendableGrids.AbstractGridIntegerConstant\n\nNumber of boundary edge regions \n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.NumBFaceRegions","page":"Extendable grid","title":"ExtendableGrids.NumBFaceRegions","text":"abstract type NumBFaceRegions <: ExtendableGrids.AbstractGridIntegerConstant\n\nNumber of boundary face regions \n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.NumCellRegions","page":"Extendable grid","title":"ExtendableGrids.NumCellRegions","text":"abstract type NumCellRegions <: ExtendableGrids.AbstractGridIntegerConstant\n\nNumber of cell regions\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#Base.delete!-Tuple{ExtendableGrid, Type{<:AbstractGridComponent}}","page":"Extendable grid","title":"Base.delete!","text":"delete!(\n    grid::ExtendableGrid,\n    T::Type{<:AbstractGridComponent}\n) -> Dict{Type{<:AbstractGridComponent}, Any}\n\n\nRemove grid component\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.get!-Tuple{ExtendableGrid, Type{<:AbstractGridComponent}}","page":"Extendable grid","title":"Base.get!","text":"get!(\n    grid::ExtendableGrid,\n    T::Type{<:AbstractGridComponent}\n) -> Any\n\n\nTo be called by getindex. This triggers lazy creation of  non-existing gridcomponents\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.getindex-Tuple{ExtendableGrid, Type{<:AbstractGridComponent}}","page":"Extendable grid","title":"Base.getindex","text":"Base.getindex(grid::ExtendableGrid,T::Type{<:AbstractGridComponent})\n\nGeneric method for obtaining grid component.\n\nThis method is mutating in the sense that non-existing grid components are created on demand.\n\nDue to the fact that components are stored as Any the return value triggers type instability. To prevent this, specialized methods must be (and are) defined.\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.haskey-Tuple{ExtendableGrid, Any}","page":"Extendable grid","title":"Base.haskey","text":"haskey(g::ExtendableGrid, k) -> Bool\n\n\nCheck if key is in grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.keys-Tuple{ExtendableGrid}","page":"Extendable grid","title":"Base.keys","text":"keys(\n    g::ExtendableGrid\n) -> Base.KeySet{Type{<:AbstractGridComponent}, Dict{Type{<:AbstractGridComponent}, Any}}\n\n\nKeys in grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.map-Tuple{Function, ExtendableGrid}","page":"Extendable grid","title":"Base.map","text":"map(f::Function, grid::ExtendableGrid) -> Any\n\n\nMap a function onto node coordinates of grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.setindex!-Tuple{ExtendableGrid, Any, Type{<:AbstractGridComponent}}","page":"Extendable grid","title":"Base.setindex!","text":"setindex!(\n    grid::ExtendableGrid,\n    v,\n    T::Type{<:AbstractGridComponent}\n) -> Any\n\n\nSet new grid component\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.coord_type-Union{Tuple{ExtendableGrid{Tc, Ti}}, Tuple{Ti}, Tuple{Tc}} where {Tc, Ti}","page":"Extendable grid","title":"ExtendableGrids.coord_type","text":"coord_type(grid)\n\n\nType of coordinates in grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.dim_grid-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.dim_grid","text":"dim_grid(grid)\n\n\nGrid dimension dimension of grid (larges element dimension)\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.dim_space-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.dim_space","text":"dim_space(grid)\n\n\nSpace dimension of grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.gridcomponents-Tuple{}","page":"Extendable grid","title":"ExtendableGrids.gridcomponents","text":"gridcomponents()\n\n\nPrint the hierarchy of grid component key types (subtypes of AbstractGridComponent.  This includes additionally user defined subptypes.\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.index_type-Union{Tuple{ExtendableGrid{Tc, Ti}}, Tuple{Ti}, Tuple{Tc}} where {Tc, Ti}","page":"Extendable grid","title":"ExtendableGrids.index_type","text":"index_type(grid)\n\n\nType of indices\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.instantiate","page":"Extendable grid","title":"ExtendableGrids.instantiate","text":"\"Hook\" for methods instantiating lazy components. \n\n\n\n\n\n","category":"function"},{"location":"extendablegrid/#ExtendableGrids.instantiate-Tuple{Any, Type{NumBEdgeRegions}}","page":"Extendable grid","title":"ExtendableGrids.instantiate","text":"instantiate(grid, _::Type{NumBEdgeRegions}) -> Any\n\n\nInstantiate number of boundary edge regions\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.instantiate-Tuple{Any, Type{NumBFaceRegions}}","page":"Extendable grid","title":"ExtendableGrids.instantiate","text":"instantiate(grid, _::Type{NumBFaceRegions}) -> Any\n\n\nInstantiate number of bface regions\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.instantiate-Tuple{Any, Type{NumCellRegions}}","page":"Extendable grid","title":"ExtendableGrids.instantiate","text":"instantiate(grid, _::Type{NumCellRegions}) -> Any\n\n\nInstantiate number of cell regions\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.isconsistent-Tuple{Any}","page":"Extendable grid","title":"ExtendableGrids.isconsistent","text":"isconsistent(grid; warnonly=false)\n\nCheck consistency of grid: a grid is consistent if\n\nGrid has no dangling nodes\n... more to be added\n\nIf grid is consistent, return true, otherwise throw an error,  or, if warnoly==true, return false.\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_bedgeregions-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_bedgeregions","text":"num_bedgeregions(grid::ExtendableGrid) -> Any\n\n\nMaximum boundary edge region numbers\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_bedges-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_bedges","text":"num_bedges(grid::ExtendableGrid) -> Int64\n\n\nNumber of boundary edges in grid.\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_bfaceregions-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_bfaceregions","text":"num_bfaceregions(grid::ExtendableGrid) -> Any\n\n\nMaximum  boundary face region numbers\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_bfaces-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_bfaces","text":"num_bfaces(grid::ExtendableGrid) -> Int64\n\n\nNumber of boundary faces in grid.\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_cellregions-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_cellregions","text":"num_cellregions(grid::ExtendableGrid) -> Any\n\n\nMaximum  cell  region number\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_cells-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_cells","text":"num_cells(grid::ExtendableGrid) -> Int64\n\n\nNumber of cells in grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_nodes-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_nodes","text":"num_nodes(grid)\n\n\nNumber of nodes in grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.seemingly_equal-Tuple{AbstractArray, AbstractArray}","page":"Extendable grid","title":"ExtendableGrids.seemingly_equal","text":"seemingly_equal(array1, array2)\n\n\nCheck for seeming equality of two arrays by random sample.\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.seemingly_equal-Tuple{ExtendableGrid, ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.seemingly_equal","text":"seemingly_equal(grid1, grid2; sort=false, confidence=:full\n\nRecursively check seeming equality of two grids. Seemingly means  that long arrays are only compared via random samples.\n\nKeyword args:\n\nsort: if true, sort grid points\nconfidence:  Confidence level: \n:low : Point numbers etc are the same\n:full : all arrays are equal (besides the coordinate array, the arrays only have to be equal up to permutations)\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.update!-Tuple{ExtendableGrid, Type{<:AbstractGridComponent}}","page":"Extendable grid","title":"ExtendableGrids.update!","text":"update!(\n    grid::ExtendableGrid,\n    T::Type{<:AbstractGridComponent}\n) -> Any\n\n\nReinstantiate grid component (only if it exists)\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.veryform-Tuple{ExtendableGrid, Any, Type{<:AbstractGridComponent}}","page":"Extendable grid","title":"ExtendableGrids.veryform","text":"veryform(\n    grid::ExtendableGrid,\n    v,\n    _::Type{<:AbstractGridComponent}\n) -> Any\n\n\nDefault veryform method.\n\n\"veryform\"  means \"verify and/or transform\"  and is called to check and possibly transform components to be added to the grid via setindex!.\n\nThe default method just passes data through.\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.veryform-Union{Tuple{Ti}, Tuple{Tc}, Tuple{ExtendableGrid{Tc, Ti}, Any, Type{<:AbstractGridAdjacency}}} where {Tc, Ti}","page":"Extendable grid","title":"ExtendableGrids.veryform","text":"veryform(grid::ExtendableGrid{Tc,Ti},v,T::Type{<:AbstractGridAdjacency}) where{Tc,Ti}\n\nCheck proper type of adjacencies upon insertion\n\n\n\n\n\n","category":"method"},{"location":"typehierarchy/#Type-hierarchy","page":"Type hierarchy","title":"Type hierarchy","text":"","category":"section"},{"location":"typehierarchy/","page":"Type hierarchy","title":"Type hierarchy","text":"The package defines a hierarchy of abstract types to handle grid compoments. The full tree is listed here:","category":"page"},{"location":"typehierarchy/","page":"Type hierarchy","title":"Type hierarchy","text":"using ExtendableGrids # hide\ntypehierarchy() #hide","category":"page"},{"location":"typehierarchy/#API","page":"Type hierarchy","title":"API","text":"","category":"section"},{"location":"typehierarchy/","page":"Type hierarchy","title":"Type hierarchy","text":"Modules = [ExtendableGrids]\nPages = [\"typehierarchy.jl\"]","category":"page"},{"location":"typehierarchy/#ExtendableGrids.AbstractExtendableGridApexType","page":"Type hierarchy","title":"ExtendableGrids.AbstractExtendableGridApexType","text":"abstract type AbstractExtendableGridApexType\n\nApex type of all abstract types in this hierarchy.\n\n\n\n\n\n","category":"type"},{"location":"typehierarchy/#AbstractTrees.children-Tuple{Type}","page":"Type hierarchy","title":"AbstractTrees.children","text":"children(T::Type) -> Union{Vector{Type}, Vector{Any}}\n\n\nDefine children for types.\n\n\n\n\n\n","category":"method"},{"location":"typehierarchy/#ExtendableGrids.typehierarchy-Tuple{}","page":"Type hierarchy","title":"ExtendableGrids.typehierarchy","text":"typehierarchy()\n\n\nPrint complete type hierachy for ExtendableGrids\n\n\n\n\n\n","category":"method"},{"location":"script_examples/examples2d/#2D-Grid-examples","page":"examples2d","title":"2D Grid examples","text":"","category":"section"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"using Triangulate, ExtendableGrids, SimplexGridFactory","category":"page"},{"location":"script_examples/examples2d/#Rectangle","page":"examples2d","title":"Rectangle","text":"","category":"section"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"function rectangle()\n    X = collect(0:0.05:1)\n    Y = collect(0:0.05:1)\n    simplexgrid(X, X)\nend","category":"page"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"(Image: )","category":"page"},{"location":"script_examples/examples2d/#Rectangle-with-local-refinement","page":"examples2d","title":"Rectangle with local refinement","text":"","category":"section"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"function rectangle_localref()\n    hmin = 0.01\n    hmax = 0.1\n    XLeft = geomspace(0.0, 0.5, hmax, hmin)\n    XRight = geomspace(0.5, 1.0, hmin, hmax)\n    X = glue(XLeft, XRight)\n    simplexgrid(X, X)\nend","category":"page"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"(Image: )","category":"page"},{"location":"script_examples/examples2d/#Rectangle-with-multiple-regions","page":"examples2d","title":"Rectangle with multiple regions","text":"","category":"section"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"function rectangle_multiregion()\n    X = collect(0:0.05:1)\n    Y = collect(0:0.05:1)\n    grid = simplexgrid(X, Y)\n    cellmask!(grid, [0.0, 0.0], [1.0, 0.5], 3)\n    bfacemask!(grid, [0.0, 0.0], [0.0, 0.5], 5)\n    bfacemask!(grid, [1.0, 0.0], [1.0, 0.5], 6)\n    bfacemask!(grid, [0.0, 0.5], [1.0, 0.5], 7)\nend","category":"page"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"(Image: )","category":"page"},{"location":"script_examples/examples2d/#Subgrid-from-rectangle","page":"examples2d","title":"Subgrid from rectangle","text":"","category":"section"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"function rectangle_subgrid()\n    X = collect(0:0.05:1)\n    Y = collect(0:0.05:1)\n    grid = simplexgrid(X, Y)\n    rect!(grid, [0.25, 0.25], [0.75, 0.75]; region = 2, bregion = 5)\n    subgrid(grid, [1])\nend","category":"page"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"(Image: )","category":"page"},{"location":"script_examples/examples2d/#Rect2d-with-bregion-function","page":"examples2d","title":"Rect2d with bregion function","text":"","category":"section"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"Here, we use function as bregion parameter - this allows to have no bfaces at the interface between the two rects.","category":"page"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"function rect2d_bregion_function()\n    X = collect(0:0.5:10)\n    Y = collect(0:0.5:10)\n    grid = simplexgrid(X, Y)\n    rect!(grid, [5, 4], [9, 6]; region = 2, bregions = [5, 5, 5, 5])\n\n    rect!(grid, [4, 2], [5, 8]; region = 2, bregion = cur -> cur == 5 ? 0 : 8)\n\n    subgrid(grid, [2])\nend","category":"page"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"(Image: )","category":"page"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"function sorted_subgrid(; maxvolume = 0.01)\n    builder = SimplexGridBuilder(; Generator = Triangulate)\n\n    p1 = point!(builder, 0, 0)\n    p2 = point!(builder, 1, 0)\n    p3 = point!(builder, 1, 2)\n    p4 = point!(builder, 0, 1)\n    p5 = point!(builder, -1, 2)\n\n    facetregion!(builder, 1)\n    facet!(builder, p1, p2)\n    facetregion!(builder, 2)\n    facet!(builder, p2, p3)\n    facetregion!(builder, 3)\n    facet!(builder, p3, p4)\n    facetregion!(builder, 4)\n    facet!(builder, p4, p5)\n    facetregion!(builder, 5)\n    facet!(builder, p5, p1)\n\n    g = simplexgrid(builder; maxvolume)\n    sg = subgrid(g, [2]; boundary = true, transform = (a, b) -> a[1] = b[2])\n    f = map((x, y) -> sin(3x) * cos(3y), g)\n    sf = view(f, sg)\n    g, sg, sf\nend","category":"page"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"(Image: )","category":"page"},{"location":"script_examples/examples2d/#CI-callbacks-for-[ExampleJuggler.jl](https://github.com/j-fu/ExampleJuggler.jl)","page":"examples2d","title":"CI callbacks  for ExampleJuggler.jl","text":"","category":"section"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"Unit tests","category":"page"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"using Test\nfunction runtests()\n    @test numbers_match(rectangle(), 441, 800, 80)\n    @test numbers_match(rectangle_localref(), 729, 1352, 104)\n    @test numbers_match(rectangle_multiregion(), 441, 800, 100)\n    @test numbers_match(rectangle_subgrid(), 360, 600, 120)\n    @test numbers_match(rect2d_bregion_function(), 79, 112, 44)\n\n    g, sg, sf = sorted_subgrid()\n    @test numbers_match(g, 187, 306, 66)\n    @test numbers_match(sg, 17, 16, 0)\n    @test issorted(view(sg[Coordinates], 1, :))\nend","category":"page"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"Plot generation","category":"page"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"using GridVisualize\nfunction generateplots(picdir; Plotter = nothing)\n    if isdefined(Plotter, :Makie)\n        size = (300, 300)\n        Plotter.save(joinpath(picdir, \"rectangle.png\"), gridplot(rectangle(); Plotter, size))\n        Plotter.save(joinpath(picdir, \"rectangle_localref.png\"), gridplot(rectangle_localref(); Plotter, size))\n        Plotter.save(joinpath(picdir, \"rectangle_multiregion.png\"), gridplot(rectangle_multiregion(); Plotter, size))\n        Plotter.save(joinpath(picdir, \"rectangle_subgrid.png\"), gridplot(rectangle_subgrid(); Plotter, size))\n        Plotter.save(joinpath(picdir, \"rect2d_bregion_function.png\"), gridplot(rect2d_bregion_function(); Plotter, size))\n\n        g, sg, sf = sorted_subgrid()\n        p = GridVisualizer(; Plotter, layout = (1, 3), size = (800, 300))\n        gridplot!(p[1, 1], g)\n        gridplot!(p[1, 2], sg)\n        scalarplot!(p[1, 3], sg, sf)\n        fname = joinpath(picdir, \"sorted_subgrid.png\")\n        Plotter.save(fname, reveal(p))\n    end\nend","category":"page"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"","category":"page"},{"location":"script_examples/examples2d/","page":"examples2d","title":"examples2d","text":"This page was generated using Literate.jl.","category":"page"},{"location":"vectorofconstants/#Vector-of-constants","page":"Vector of constants","title":"Vector of constants","text":"","category":"section"},{"location":"vectorofconstants/","page":"Vector of constants","title":"Vector of constants","text":"Datatype to store vector with a constant value.","category":"page"},{"location":"vectorofconstants/#API","page":"Vector of constants","title":"API","text":"","category":"section"},{"location":"vectorofconstants/","page":"Vector of constants","title":"Vector of constants","text":"Modules = [ExtendableGrids]\nPages = [\"vectorofconstants.jl\"]","category":"page"},{"location":"vectorofconstants/#ExtendableGrids.VectorOfConstants","page":"Vector of constants","title":"ExtendableGrids.VectorOfConstants","text":"struct VectorOfConstants{T, Tl} <: AbstractArray{T, 1}\n\nVector with constant value\n\n\n\n\n\n","category":"type"},{"location":"vectorofconstants/#Base.getindex-Tuple{VectorOfConstants, Any}","page":"Vector of constants","title":"Base.getindex","text":"getindex(v::VectorOfConstants, i) -> Any\n\n\nAccess\n\n\n\n\n\n","category":"method"},{"location":"vectorofconstants/#Base.iterate-Tuple{VectorOfConstants, Any}","page":"Vector of constants","title":"Base.iterate","text":"iterate(\n    v::VectorOfConstants,\n    state\n) -> Union{Nothing, Tuple{Any, Any}}\n\n\nIterator\n\n\n\n\n\n","category":"method"},{"location":"vectorofconstants/#Base.iterate-Tuple{VectorOfConstants}","page":"Vector of constants","title":"Base.iterate","text":"iterate(v::VectorOfConstants) -> Tuple{Any, Int64}\n\n\nIterator\n\n\n\n\n\n","category":"method"},{"location":"vectorofconstants/#Base.length-Tuple{VectorOfConstants}","page":"Vector of constants","title":"Base.length","text":"length(v::VectorOfConstants) -> Any\n\n\nLength\n\n\n\n\n\n","category":"method"},{"location":"vectorofconstants/#Base.size-Tuple{VectorOfConstants}","page":"Vector of constants","title":"Base.size","text":"size(v::VectorOfConstants) -> Tuple{Any}\n\n\nSize\n\n\n\n\n\n","category":"method"},{"location":"vectorofconstants/#Base.unique-Tuple{VectorOfConstants}","page":"Vector of constants","title":"Base.unique","text":"unique(v::VectorOfConstants) -> Vector\n\n\nShortcut for unique\n\n\n\n\n\n","category":"method"},{"location":"elementgeometry/#Element-geometry","page":"Element geometry","title":"Element geometry","text":"","category":"section"},{"location":"elementgeometry/","page":"Element geometry","title":"Element geometry","text":"Element geometries are described via abstract types. The list of element geometries systems can be obtained with the elementgeometries method:","category":"page"},{"location":"elementgeometry/","page":"Element geometry","title":"Element geometry","text":"using ExtendableGrids # hide\nelementgeometries() #hide","category":"page"},{"location":"elementgeometry/#API","page":"Element geometry","title":"API","text":"","category":"section"},{"location":"elementgeometry/","page":"Element geometry","title":"Element geometry","text":"Modules = [ExtendableGrids]\nPages = [\"elementgeometry.jl\"]","category":"page"},{"location":"elementgeometry/#ExtendableGrids.AbstractElementGeometry","page":"Element geometry","title":"ExtendableGrids.AbstractElementGeometry","text":"abstract type AbstractElementGeometry <: AbstractExtendableGridApexType\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.AbstractElementGeometry0D","page":"Element geometry","title":"ExtendableGrids.AbstractElementGeometry0D","text":"abstract type AbstractElementGeometry0D <: AbstractElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.AbstractElementGeometry1D","page":"Element geometry","title":"ExtendableGrids.AbstractElementGeometry1D","text":"abstract type AbstractElementGeometry1D <: AbstractElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.AbstractElementGeometry2D","page":"Element geometry","title":"ExtendableGrids.AbstractElementGeometry2D","text":"abstract type AbstractElementGeometry2D <: AbstractElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.AbstractElementGeometry3D","page":"Element geometry","title":"ExtendableGrids.AbstractElementGeometry3D","text":"abstract type AbstractElementGeometry3D <: AbstractElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.AbstractElementGeometry4D","page":"Element geometry","title":"ExtendableGrids.AbstractElementGeometry4D","text":"abstract type AbstractElementGeometry4D <: AbstractElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Circle2D","page":"Element geometry","title":"ExtendableGrids.Circle2D","text":"abstract type Circle2D <: AbstractElementGeometry2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Edge1D","page":"Element geometry","title":"ExtendableGrids.Edge1D","text":"abstract type Edge1D <: AbstractElementGeometry1D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Hexagon2D","page":"Element geometry","title":"ExtendableGrids.Hexagon2D","text":"abstract type Hexagon2D <: Polygon2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Hexahedron3D","page":"Element geometry","title":"ExtendableGrids.Hexahedron3D","text":"abstract type Hexahedron3D <: Polyhedron3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.HyperCube4D","page":"Element geometry","title":"ExtendableGrids.HyperCube4D","text":"abstract type HyperCube4D <: AbstractElementGeometry4D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Parallelepiped3D","page":"Element geometry","title":"ExtendableGrids.Parallelepiped3D","text":"abstract type Parallelepiped3D <: Hexahedron3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Parallelogram2D","page":"Element geometry","title":"ExtendableGrids.Parallelogram2D","text":"abstract type Parallelogram2D <: Quadrilateral2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Pentagon2D","page":"Element geometry","title":"ExtendableGrids.Pentagon2D","text":"abstract type Pentagon2D <: Polygon2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Polychoron4D","page":"Element geometry","title":"ExtendableGrids.Polychoron4D","text":"abstract type Polychoron4D <: AbstractElementGeometry4D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Polygon2D","page":"Element geometry","title":"ExtendableGrids.Polygon2D","text":"abstract type Polygon2D <: AbstractElementGeometry2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Polyhedron3D","page":"Element geometry","title":"ExtendableGrids.Polyhedron3D","text":"abstract type Polyhedron3D <: AbstractElementGeometry3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Prism3D","page":"Element geometry","title":"ExtendableGrids.Prism3D","text":"abstract type Prism3D <: Polyhedron3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Quadrilateral2D","page":"Element geometry","title":"ExtendableGrids.Quadrilateral2D","text":"abstract type Quadrilateral2D <: Polygon2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Rectangle2D","page":"Element geometry","title":"ExtendableGrids.Rectangle2D","text":"abstract type Rectangle2D <: Parallelogram2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.RectangularCuboid3D","page":"Element geometry","title":"ExtendableGrids.RectangularCuboid3D","text":"abstract type RectangularCuboid3D <: Parallelepiped3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Sphere3D","page":"Element geometry","title":"ExtendableGrids.Sphere3D","text":"abstract type Sphere3D <: AbstractElementGeometry3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Tetrahedron3D","page":"Element geometry","title":"ExtendableGrids.Tetrahedron3D","text":"abstract type Tetrahedron3D <: Polyhedron3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Triangle2D","page":"Element geometry","title":"ExtendableGrids.Triangle2D","text":"abstract type Triangle2D <: Polygon2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.TrianglePrism3D","page":"Element geometry","title":"ExtendableGrids.TrianglePrism3D","text":"abstract type TrianglePrism3D <: Prism3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Vertex0D","page":"Element geometry","title":"ExtendableGrids.Vertex0D","text":"abstract type Vertex0D <: AbstractElementGeometry0D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.dim_element-Tuple{Type{<:AbstractElementGeometry0D}}","page":"Element geometry","title":"ExtendableGrids.dim_element","text":"dim_element(_::Type{<:AbstractElementGeometry0D}) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"elementgeometry/#ExtendableGrids.dim_element-Tuple{Type{<:AbstractElementGeometry1D}}","page":"Element geometry","title":"ExtendableGrids.dim_element","text":"dim_element(_::Type{<:AbstractElementGeometry1D}) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"elementgeometry/#ExtendableGrids.dim_element-Tuple{Type{<:AbstractElementGeometry2D}}","page":"Element geometry","title":"ExtendableGrids.dim_element","text":"dim_element(_::Type{<:AbstractElementGeometry2D}) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"elementgeometry/#ExtendableGrids.dim_element-Tuple{Type{<:AbstractElementGeometry3D}}","page":"Element geometry","title":"ExtendableGrids.dim_element","text":"dim_element(_::Type{<:AbstractElementGeometry3D}) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"elementgeometry/#ExtendableGrids.dim_element-Tuple{Type{<:AbstractElementGeometry4D}}","page":"Element geometry","title":"ExtendableGrids.dim_element","text":"dim_element(_::Type{<:AbstractElementGeometry4D}) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"elementgeometry/#ExtendableGrids.elementgeometries-Tuple{}","page":"Element geometry","title":"ExtendableGrids.elementgeometries","text":"elementgeometries()\n\n\nList supported element geometries.\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#Token-streams","page":"Token streams","title":"Token streams","text":"","category":"section"},{"location":"tokenstream/","page":"Token streams","title":"Token streams","text":"The TokenStream struct supports reading of tokenizable ASCII files","category":"page"},{"location":"tokenstream/#API","page":"Token streams","title":"API","text":"","category":"section"},{"location":"tokenstream/","page":"Token streams","title":"Token streams","text":"Modules = [ExtendableGrids]\nPages = [\"tokenstream.jl\"]","category":"page"},{"location":"tokenstream/#ExtendableGrids.TokenStream","page":"Token streams","title":"ExtendableGrids.TokenStream","text":"mutable struct TokenStream\n\nTokenstream allows to read tokenized data from file without keeping the file ocntent in memory.\n\ninput::IOStream: Input stream\n\ntokens::Vector{SubString{String}}: Array of current tokens kept in memory.\n\nitoken::Int64: Position of actual token in tokens array\n\nlineno::Int64: Line number in IOStream\n\ncomment::Char: Comment character\n\ndlm::Function: Function telling if given character is a delimiter.\n\n\n\n\n\n","category":"type"},{"location":"tokenstream/#ExtendableGrids.TokenStream-Tuple{IOStream}","page":"Token streams","title":"ExtendableGrids.TokenStream","text":"TokenStream(input::IOStream; comment, dlm) -> TokenStream\n\n\nCreate Tokenstream with IOStream argument.\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#ExtendableGrids.TokenStream-Tuple{String}","page":"Token streams","title":"ExtendableGrids.TokenStream","text":"TokenStream(filename::String; comment, dlm) -> TokenStream\n\n\nCreate Tokenstream with file name argument.\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#ExtendableGrids.UnexpectedTokenError","page":"Token streams","title":"ExtendableGrids.UnexpectedTokenError","text":"struct UnexpectedTokenError <: Exception\n\nError thrown when the token expected  in expect!  is not there.\n\nfound::String\nexpected::String\nlineno::Int64\n\n\n\n\n\n","category":"type"},{"location":"tokenstream/#Base.eof-Tuple{TokenStream}","page":"Token streams","title":"Base.eof","text":"eof(tks::TokenStream) -> Bool\n\n\nCheck if all tokens have been consumed.\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#ExtendableGrids.destruct!-Tuple{TokenStream}","page":"Token streams","title":"ExtendableGrids.destruct!","text":"destruct!(tks::TokenStream)\n\n\nTokenstream destructor should close input\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#ExtendableGrids.expecttoken-Tuple{TokenStream, String}","page":"Token streams","title":"ExtendableGrids.expecttoken","text":"expecttoken(tks::TokenStream, expected::String) -> Bool\n\n\nExpect keyword token.\n\nIf token is missing, an UnexpectedTokenError is thrown If the token  has been found, reading will continue  at the position after the token found.\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#ExtendableGrids.gettoken-Tuple{TokenStream}","page":"Token streams","title":"ExtendableGrids.gettoken","text":"gettoken(\n    tks::TokenStream\n) -> Union{Nothing, SubString{String}}\n\n\nGet next token from tokenstream.\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#ExtendableGrids.trytoken-Tuple{TokenStream, String}","page":"Token streams","title":"ExtendableGrids.trytoken","text":"trytoken(tks::TokenStream, expected::String) -> Bool\n\n\nTry for keyword token.\n\nIt token is missing, the token read is put back into stream, a value of false is returned and the next try/gettoken command continues at the same position,\n\nOtherwise, true is returned, and reading continues after the token found.\n\n\n\n\n\n","category":"method"},{"location":"script_examples/gmsh/#Gmsh-examples","page":"gmsh","title":"Gmsh examples","text":"","category":"section"},{"location":"script_examples/gmsh/","page":"gmsh","title":"gmsh","text":"using ExtendableGrids\nusing Gmsh: gmsh","category":"page"},{"location":"script_examples/gmsh/","page":"gmsh","title":"gmsh","text":"Example t1  from the GMSH docs","category":"page"},{"location":"script_examples/gmsh/","page":"gmsh","title":"gmsh","text":"function gmsh_t1()\n    gmsh.initialize()\n    gmsh.option.setNumber(\"General.Terminal\", 1)\n    gmsh.model.add(\"t1\")\n\n    lc = 1e-2\n    gmsh.model.geo.addPoint(0, 0, 0, lc, 1)\n    gmsh.model.geo.addPoint(0.1, 0, 0, lc, 2)\n    gmsh.model.geo.addPoint(0.1, 0.3, 0, lc, 3)\n\n    p4 = gmsh.model.geo.addPoint(0, 0.3, 0, lc)\n\n    gmsh.model.geo.addLine(1, 2, 1)\n    gmsh.model.geo.addLine(3, 2, 2)\n    gmsh.model.geo.addLine(3, p4, 3)\n    gmsh.model.geo.addLine(4, 1, p4)\n\n    gmsh.model.geo.addCurveLoop([4, 1, -2, 3], 1)\n    gmsh.model.geo.addPlaneSurface([1], 1)\n\n    gmsh.model.geo.synchronize()\n\n    gmsh.model.addPhysicalGroup(0, [1, 2], 1)\n    gmsh.model.addPhysicalGroup(1, [1, 2], 2)\n    gmsh.model.addPhysicalGroup(2, [1], 6)\n\n    gmsh.model.setPhysicalName(2, 6, \"My surface\")\n\n    gmsh.model.mesh.generate(2)\n    grid = ExtendableGrids.simplexgrid_from_gmsh(gmsh.model)\n    gmsh.finalize()\n    grid\nend","category":"page"},{"location":"script_examples/gmsh/","page":"gmsh","title":"gmsh","text":"(Image: )","category":"page"},{"location":"script_examples/gmsh/","page":"gmsh","title":"gmsh","text":"Example t4  from the GMSH docs","category":"page"},{"location":"script_examples/gmsh/","page":"gmsh","title":"gmsh","text":"function gmsh_t4()\n    gmsh.initialize()\n\n    gmsh.model.add(\"t4\")\n\n    cm = 1e-02\n    e1 = 4.5 * cm; e2 = 6 * cm / 2; e3 =  5 * cm / 2\n    h1 = 5 * cm; h2 = 10 * cm; h3 = 5 * cm; h4 = 2 * cm; h5 = 4.5 * cm\n    R1 = 1 * cm; R2 = 1.5 * cm; r = 1 * cm\n    Lc1 = 0.01\n    Lc2 = 0.003\n\n    function hypot(a, b)\n        return sqrt(a * a + b * b)\n    end\n\n    ccos = (-h5*R1 + e2 * hypot(h5, hypot(e2, R1))) / (h5*h5 + e2*e2)\n    ssin = sqrt(1 - ccos*ccos)\n\n    factory = gmsh.model.geo\n    factory.addPoint(-e1-e2, 0    , 0, Lc1, 1)\n    factory.addPoint(-e1-e2, h1   , 0, Lc1, 2)\n    factory.addPoint(-e3-r , h1   , 0, Lc2, 3)\n    factory.addPoint(-e3-r , h1+r , 0, Lc2, 4)\n    factory.addPoint(-e3   , h1+r , 0, Lc2, 5)\n    factory.addPoint(-e3   , h1+h2, 0, Lc1, 6)\n    factory.addPoint( e3   , h1+h2, 0, Lc1, 7)\n    factory.addPoint( e3   , h1+r , 0, Lc2, 8)\n    factory.addPoint( e3+r , h1+r , 0, Lc2, 9)\n    factory.addPoint( e3+r , h1   , 0, Lc2, 10)\n    factory.addPoint( e1+e2, h1   , 0, Lc1, 11)\n    factory.addPoint( e1+e2, 0    , 0, Lc1, 12)\n    factory.addPoint( e2   , 0    , 0, Lc1, 13)\n\n    factory.addPoint( R1 / ssin, h5+R1*ccos, 0, Lc2, 14)\n    factory.addPoint( 0        , h5        , 0, Lc2, 15)\n    factory.addPoint(-R1 / ssin, h5+R1*ccos, 0, Lc2, 16)\n    factory.addPoint(-e2       , 0.0       , 0, Lc1, 17)\n\n    factory.addPoint(-R2 , h1+h3   , 0, Lc2, 18)\n    factory.addPoint(-R2 , h1+h3+h4, 0, Lc2, 19)\n    factory.addPoint( 0  , h1+h3+h4, 0, Lc2, 20)\n    factory.addPoint( R2 , h1+h3+h4, 0, Lc2, 21)\n    factory.addPoint( R2 , h1+h3   , 0, Lc2, 22)\n    factory.addPoint( 0  , h1+h3   , 0, Lc2, 23)\n\n    factory.addPoint( 0, h1+h3+h4+R2, 0, Lc2, 24)\n    factory.addPoint( 0, h1+h3-R2,    0, Lc2, 25)\n\n    factory.addLine(1 , 17, 1)\n    factory.addLine(17, 16, 2)\n\n    factory.addCircleArc(14,15,16, 3)\n    factory.addLine(14,13, 4)\n    factory.addLine(13,12, 5)\n    factory.addLine(12,11, 6)\n    factory.addLine(11,10, 7)\n    factory.addCircleArc(8,9,10, 8)\n    factory.addLine(8,7, 9)\n    factory.addLine(7,6, 10)\n    factory.addLine(6,5, 11)\n    factory.addCircleArc(3,4,5, 12)\n    factory.addLine(3,2, 13)\n    factory.addLine(2,1, 14)\n    factory.addLine(18,19, 15)\n    factory.addCircleArc(21,20,24, 16)\n    factory.addCircleArc(24,20,19, 17)\n    factory.addCircleArc(18,23,25, 18)\n    factory.addCircleArc(25,23,22, 19)\n    factory.addLine(21,22, 20)\n\n    factory.addCurveLoop([17,-15,18,19,-20,16], 21)\n    factory.addPlaneSurface([21], 22)\n    factory.addCurveLoop([11,-12,13,14,1,2,-3,4,5,6,7,-8,9,10], 23)\n\n    factory.addPlaneSurface([23,21], 24)\n\n    factory.synchronize()\n\n    v = gmsh.view.add(\"comments\")\n\n    gmsh.view.addListDataString(v, [10, -10], [\"Created with Gmsh\"])\n\n    gmsh.view.addListDataString(v, [0, 0.11, 0], [\"Hole\"],\n                                [\"Align\", \"Center\", \"Font\", \"Helvetica\"])\n\n    gmsh.view.addListDataString(v, [0, 0.09, 0], [\"file://../t4_image.png@0.01x0\"],\n                                [\"Align\", \"Center\"])\n\n    gmsh.view.addListDataString(v, [-0.01, 0.09, 0],\n                                [\"file://../t4_image.png@0.01x0,0,0,1,0,1,0\"])\n\n    gmsh.view.addListDataString(v, [0, 0.12, 0],\n                                [\"file://../t4_image.png@0.01x0#\"],\n                                [\"Align\", \"Center\"])\n\n    gmsh.view.addListDataString(v, [150, -7], [\"file://../t4_image.png@20x0\"])\n\n    gmsh.view.option.setString(v, \"DoubleClickedCommand\",\n                               \"Printf('View[0] has been double-clicked!');\")\n    gmsh.option.setString(\n        \"Geometry.DoubleClickedLineCommand\",\n        \"Printf('Curve %g has been double-clicked!', Geometry.DoubleClickedEntityTag);\")\n\n    gmsh.model.setColor([(2, 22)], 127, 127, 127)\n    gmsh.model.setColor([(2, 24)], 160, 32, 240)\n    gmsh.model.setColor([(1, i) for i in 1:14], 255, 0, 0)\n    gmsh.model.setColor([(1, i) for i in 15:20], 255, 255, 0)\n\n    gmsh.model.mesh.generate(2)\n    grid = ExtendableGrids.simplexgrid_from_gmsh(gmsh.model)\n    gmsh.finalize()\n    grid\nend","category":"page"},{"location":"script_examples/gmsh/","page":"gmsh","title":"gmsh","text":"(Image: )","category":"page"},{"location":"script_examples/gmsh/","page":"gmsh","title":"gmsh","text":"Example t5  from the GMSH docs","category":"page"},{"location":"script_examples/gmsh/","page":"gmsh","title":"gmsh","text":"function gmsh_t5()\n\n    gmsh.initialize()\n\n    gmsh.model.add(\"t5\")\n\n    lcar1 = .1\n    lcar2 = .0005\n    lcar3 = .055\n\n    gmsh.model.geo.addPoint(0.5,0.5,0.5, lcar2, 1)\n    gmsh.model.geo.addPoint(0.5,0.5,0, lcar1, 2)\n    gmsh.model.geo.addPoint(0,0.5,0.5, lcar1, 3)\n    gmsh.model.geo.addPoint(0,0,0.5, lcar1, 4)\n    gmsh.model.geo.addPoint(0.5,0,0.5, lcar1, 5)\n    gmsh.model.geo.addPoint(0.5,0,0, lcar1, 6)\n    gmsh.model.geo.addPoint(0,0.5,0, lcar1, 7)\n    gmsh.model.geo.addPoint(0,1,0, lcar1, 8)\n    gmsh.model.geo.addPoint(1,1,0, lcar1, 9)\n    gmsh.model.geo.addPoint(0,0,1, lcar1, 10)\n    gmsh.model.geo.addPoint(0,1,1, lcar1, 11)\n    gmsh.model.geo.addPoint(1,1,1, lcar1, 12)\n    gmsh.model.geo.addPoint(1,0,1, lcar1, 13)\n    gmsh.model.geo.addPoint(1,0,0, lcar1, 14)\n\n    gmsh.model.geo.addLine(8,9, 1);   gmsh.model.geo.addLine(9,12, 2)\n    gmsh.model.geo.addLine(12,11, 3); gmsh.model.geo.addLine(11,8, 4)\n    gmsh.model.geo.addLine(9,14, 5);  gmsh.model.geo.addLine(14,13, 6)\n    gmsh.model.geo.addLine(13,12, 7); gmsh.model.geo.addLine(11,10, 8)\n    gmsh.model.geo.addLine(10,13, 9); gmsh.model.geo.addLine(10,4, 10)\n    gmsh.model.geo.addLine(4,5, 11);  gmsh.model.geo.addLine(5,6, 12)\n    gmsh.model.geo.addLine(6,2, 13);  gmsh.model.geo.addLine(2,1, 14)\n    gmsh.model.geo.addLine(1,3, 15);  gmsh.model.geo.addLine(3,7, 16)\n    gmsh.model.geo.addLine(7,2, 17);  gmsh.model.geo.addLine(3,4, 18)\n    gmsh.model.geo.addLine(5,1, 19);  gmsh.model.geo.addLine(7,8, 20)\n    gmsh.model.geo.addLine(6,14, 21);\n\n    gmsh.model.geo.addCurveLoop([-11,-19,-15,-18], 22)\n    gmsh.model.geo.addPlaneSurface([22], 23)\n    gmsh.model.geo.addCurveLoop([16,17,14,15], 24)\n    gmsh.model.geo.addPlaneSurface([24], 25)\n    gmsh.model.geo.addCurveLoop([-17,20,1,5,-21,13], 26)\n    gmsh.model.geo.addPlaneSurface([26], 27)\n    gmsh.model.geo.addCurveLoop([-4,-1,-2,-3], 28)\n    gmsh.model.geo.addPlaneSurface([28], 29)\n    gmsh.model.geo.addCurveLoop([-7,2,-5,-6], 30)\n    gmsh.model.geo.addPlaneSurface([30], 31)\n    gmsh.model.geo.addCurveLoop([6,-9,10,11,12,21], 32)\n    gmsh.model.geo.addPlaneSurface([32], 33)\n    gmsh.model.geo.addCurveLoop([7,3,8,9], 34)\n    gmsh.model.geo.addPlaneSurface([34], 35)\n    gmsh.model.geo.addCurveLoop([-10,18,-16,-20,4,-8], 36)\n    gmsh.model.geo.addPlaneSurface([36], 37)\n    gmsh.model.geo.addCurveLoop([-14,-13,-12,19], 38)\n    gmsh.model.geo.addPlaneSurface([38], 39)\n\n    shells = []\n\n    sl = gmsh.model.geo.addSurfaceLoop([35,31,29,37,33,23,39,25,27])\n    push!(shells, sl)\n\n    function cheeseHole(x, y, z, r, lc, shells)\n        p1 = gmsh.model.geo.addPoint(x,  y,  z,   lc)\n        p2 = gmsh.model.geo.addPoint(x+r,y,  z,   lc)\n        p3 = gmsh.model.geo.addPoint(x,  y+r,z,   lc)\n        p4 = gmsh.model.geo.addPoint(x,  y,  z+r, lc)\n        p5 = gmsh.model.geo.addPoint(x-r,y,  z,   lc)\n        p6 = gmsh.model.geo.addPoint(x,  y-r,z,   lc)\n        p7 = gmsh.model.geo.addPoint(x,  y,  z-r, lc)\n\n        c1 = gmsh.model.geo.addCircleArc(p2,p1,p7)\n        c2 = gmsh.model.geo.addCircleArc(p7,p1,p5)\n        c3 = gmsh.model.geo.addCircleArc(p5,p1,p4)\n        c4 = gmsh.model.geo.addCircleArc(p4,p1,p2)\n        c5 = gmsh.model.geo.addCircleArc(p2,p1,p3)\n        c6 = gmsh.model.geo.addCircleArc(p3,p1,p5)\n        c7 = gmsh.model.geo.addCircleArc(p5,p1,p6)\n        c8 = gmsh.model.geo.addCircleArc(p6,p1,p2)\n        c9 = gmsh.model.geo.addCircleArc(p7,p1,p3)\n        c10 = gmsh.model.geo.addCircleArc(p3,p1,p4)\n        c11 = gmsh.model.geo.addCircleArc(p4,p1,p6)\n        c12 = gmsh.model.geo.addCircleArc(p6,p1,p7)\n\n        l1 = gmsh.model.geo.addCurveLoop([c5,c10,c4])\n        l2 = gmsh.model.geo.addCurveLoop([c9,-c5,c1])\n        l3 = gmsh.model.geo.addCurveLoop([c12,-c8,-c1])\n        l4 = gmsh.model.geo.addCurveLoop([c8,-c4,c11])\n        l5 = gmsh.model.geo.addCurveLoop([-c10,c6,c3])\n        l6 = gmsh.model.geo.addCurveLoop([-c11,-c3,c7])\n        l7 = gmsh.model.geo.addCurveLoop([-c2,-c7,-c12])\n        l8 = gmsh.model.geo.addCurveLoop([-c6,-c9,c2])\n\n        s1 = gmsh.model.geo.addSurfaceFilling([l1])\n        s2 = gmsh.model.geo.addSurfaceFilling([l2])\n        s3 = gmsh.model.geo.addSurfaceFilling([l3])\n        s4 = gmsh.model.geo.addSurfaceFilling([l4])\n        s5 = gmsh.model.geo.addSurfaceFilling([l5])\n        s6 = gmsh.model.geo.addSurfaceFilling([l6])\n        s7 = gmsh.model.geo.addSurfaceFilling([l7])\n        s8 = gmsh.model.geo.addSurfaceFilling([l8])\n\n        sl = gmsh.model.geo.addSurfaceLoop([s1, s2, s3, s4, s5, s6, s7, s8])\n        v = gmsh.model.geo.addVolume([sl])\n        push!(shells, sl)\n        return v\n    end\n\n    x = 0\n    y = 0.75; z = 0; r = 0.09\n    for t in 1:5\n        x += 0.166\n        z += 0.166\n        v = cheeseHole(x, y, z, r, lcar3, shells)\n        gmsh.model.geo.addPhysicalGroup(3, [v], t)\n    end\n\n    gmsh.model.geo.addVolume(shells, 186);\n\n    gmsh.model.geo.synchronize()\n\n    gmsh.model.addPhysicalGroup(3, [186], 10);\n\n    gmsh.model.mesh.generate(3)\n    grid = ExtendableGrids.simplexgrid_from_gmsh(gmsh.model)\n    gmsh.finalize()\n    grid\nend","category":"page"},{"location":"script_examples/gmsh/","page":"gmsh","title":"gmsh","text":"(Image: )","category":"page"},{"location":"script_examples/gmsh/#CI-callbacks-for-[ExampleJuggler.jl](https://github.com/j-fu/ExampleJuggler.jl)","page":"gmsh","title":"CI callbacks for ExampleJuggler.jl","text":"","category":"section"},{"location":"script_examples/gmsh/","page":"gmsh","title":"gmsh","text":"Unit tests","category":"page"},{"location":"script_examples/gmsh/","page":"gmsh","title":"gmsh","text":"using Test\nfunction runtests()\n    ok(grid)= num_nodes(grid) > 0 && num_cells(grid) > 0 && num_bfaces(grid) > 0\n    @test ok(gmsh_t1())\n    @test ok(gmsh_t4())\n    @test ok(gmsh_t5())\nend","category":"page"},{"location":"script_examples/gmsh/","page":"gmsh","title":"gmsh","text":"Plot generation","category":"page"},{"location":"script_examples/gmsh/","page":"gmsh","title":"gmsh","text":"using GridVisualize\nfunction generateplots(picdir; Plotter = nothing)\n    if isdefined(Plotter, :Makie)\n        size = (500, 500)\n        Plotter.save(joinpath(picdir, \"gmsh_t1.png\"), gridplot(gmsh_t1(); Plotter, size))\n        Plotter.save(joinpath(picdir, \"gmsh_t4.png\"), gridplot(gmsh_t4(); Plotter, size))\n        Plotter.save(joinpath(picdir, \"gmsh_t5.png\"), gridplot(gmsh_t5(); Plotter, size))\n    end\nend","category":"page"},{"location":"script_examples/gmsh/","page":"gmsh","title":"gmsh","text":"","category":"page"},{"location":"script_examples/gmsh/","page":"gmsh","title":"gmsh","text":"This page was generated using Literate.jl.","category":"page"},{"location":"arraytools/#Array-tools","page":"Array tools","title":"Array tools","text":"","category":"section"},{"location":"arraytools/#API","page":"Array tools","title":"API","text":"","category":"section"},{"location":"arraytools/","page":"Array tools","title":"Array tools","text":"Modules = [ExtendableGrids]\nPages = [\"arraytools.jl\"]","category":"page"},{"location":"arraytools/#ExtendableGrids.geomspace-NTuple{4, Any}","page":"Array tools","title":"ExtendableGrids.geomspace","text":"geomspace(a, b, ha, hb; tol, maxiterations) -> Any\n\n\n(Try to) create a subdivision of interval (a,b) stored in the  returned array X such that \n\nX[1]==a, X[end]==b\n(X[2]-X[1])<=ha+tol*(b-a)\n(X[end]-X[end-1])<=hb+tol*(b-a)\nThere is a number q such that  X[i+1]-X[i] == q*(X[i]-X[i-1])\nX is the array with the minimal possible number of points with the above property\n\nCaveat: the algorithm behind this is  tested for many cases but unproven.\n\nReturns an Array containing the points of the subdivision.\n\n\n\n\n\n","category":"method"},{"location":"arraytools/#ExtendableGrids.glue-Tuple{AbstractVector, AbstractVector}","page":"Array tools","title":"ExtendableGrids.glue","text":"c=glue(a,b)\n\nGlue together two vectors a and b resulting in a vector c. They last element  of a shall be equal (up to tol) to the first element of b. The result fulfills length(c)=length(a)+length(b)-1\n\n\n\n\n\n","category":"method"},{"location":"arraytools/#ExtendableGrids.linspace-Tuple{Any, Any, Any}","page":"Array tools","title":"ExtendableGrids.linspace","text":"linspace(a, b, n) -> Any\n\n\nResurrect linspace despite https://github.com/JuliaLang/julia/pull/25896#issuecomment-363769368\n\n\n\n\n\n","category":"method"},{"location":"regionedit/#Region-editing","page":"Region editing","title":"Region editing","text":"","category":"section"},{"location":"regionedit/","page":"Region editing","title":"Region editing","text":"Tools for editing grid region numbers","category":"page"},{"location":"regionedit/","page":"Region editing","title":"Region editing","text":"cellmask!\nbfacemask!\nrect!\nbedgemask!","category":"page"},{"location":"regionedit/#ExtendableGrids.cellmask!","page":"Region editing","title":"ExtendableGrids.cellmask!","text":"cellmask!(\n    grid::ExtendableGrid,\n    maskmin,\n    maskmax,\n    ireg::Int64;\n    tol\n) -> ExtendableGrid\n\n\nEdit region numbers of grid cells via rectangular mask.\n\nExamples: Rectangle-with-multiple-regions\n\n\n\n\n\n","category":"function"},{"location":"regionedit/#ExtendableGrids.bfacemask!","page":"Region editing","title":"ExtendableGrids.bfacemask!","text":"bfacemask!(grid::ExtendableGrid,\n                maskmin,\n                maskmax,\n                ireg;\n                allow_new=true,\n                tol=1.0e-10)\n\nEdit region numbers of grid  boundary facets  via rectangular mask. If allow_new is true (default), new facets are added.\n\nireg may be an integer  or a function ireg(current_region).\n\nA zero region number removes boundary faces.\n\nExamples: Rectangle-with-multiple-regions\n\n\n\n\n\n","category":"function"},{"location":"regionedit/#ExtendableGrids.rect!","page":"Region editing","title":"ExtendableGrids.rect!","text":"rect!(grid,maskmin,maskmax; \n      region=1, \n      bregion=1, \n      bregions=nothing, \n      tol=1.0e-10)\n\nPlace a rectangle into a rectangular grid. It places a cellmask according to maskmin and maskmax, and introduces boundary faces via `bfacesmask! at all sides of the mask area. It is checked that the coordinate values in the mask match (with tolerance) corresponding directional coordinates of the grid.\n\nIf bregions is given it is assumed to be a vector corresponding to the number of sides, im the sequence w,e in 1D. s,e,n,w in 2D and s,e,n,w,b,t in 3D.\n\nbregion or elements of bregions can be numbers or functions ireg(current_region).\n\nExamples: Subgrid-from-rectangle, Rect2d-with-bregion-function,  Cross3d\n\n\n\n\n\n","category":"function"},{"location":"regionedit/#ExtendableGrids.bedgemask!","page":"Region editing","title":"ExtendableGrids.bedgemask!","text":"bedgemask!(\n    grid::ExtendableGrid,\n    xa,\n    xb,\n    ireg::Int64;\n    tol\n) -> ExtendableGrid\n\n\nEdit region numbers of grid  boundary edges via line mask. This only works for 3D grids.\n\n\n\n\n\n","category":"function"},{"location":"cellfinder/#Search-and-Interpolation","page":"Search and Interpolation","title":"Search and Interpolation","text":"","category":"section"},{"location":"cellfinder/#Search","page":"Search and Interpolation","title":"Search","text":"","category":"section"},{"location":"cellfinder/","page":"Search and Interpolation","title":"Search and Interpolation","text":"CellFinder\ngFindLocal!\ngFindBruteForce!","category":"page"},{"location":"cellfinder/#ExtendableGrids.CellFinder","page":"Search and Interpolation","title":"ExtendableGrids.CellFinder","text":"struct CellFinder{Tv, Ti}\n\nCellFinder supports finding cells in grids.\n\n\n\n\n\n","category":"type"},{"location":"cellfinder/#ExtendableGrids.gFindLocal!","page":"Search and Interpolation","title":"ExtendableGrids.gFindLocal!","text":"icellfound=GFindLocal!(xref,cellfinder,p; icellstart=1,eps=1.0e-14, trybrute=true)\n\nFind cell containing point p  starting with cell number icellstart.\n\nReturns cell number if found, zero otherwise. If trybrute==true try gFindBruteForce! before giving up. Upon return, xref contains the barycentric coordinates of the point in the sequence  dim+1, 1...dim\n\nwarning: Warning\nCurrently implemented for simplex grids only.\n\n\n\n\n\n","category":"function"},{"location":"cellfinder/#ExtendableGrids.gFindBruteForce!","page":"Search and Interpolation","title":"ExtendableGrids.gFindBruteForce!","text":"icellfound=gFindBruteForce!(xref,cellfinder,p; icellstart=1,eps=1.0e-14)\n\nFind cell containing point p  starting with cell number icellstart.\n\nReturns cell number if found, zero otherwise. Upon return, xref contains the barycentric coordinates of the point in the sequence  dim+1, 1...dim\n\nwarning: Warning\nCurrently implemented for simplex grids only.\n\n\n\n\n\n","category":"function"},{"location":"cellfinder/#Interpolation","page":"Search and Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"cellfinder/","page":"Search and Interpolation","title":"Search and Interpolation","text":"interpolate\ninterpolate!","category":"page"},{"location":"cellfinder/#ExtendableGrids.interpolate","page":"Search and Interpolation","title":"ExtendableGrids.interpolate","text":"u_to=interpolate(grid_to, u_from, grid_from;eps=1.0e-14,trybrute=true)\n\nPiecewise linear interpolation of function u_from on grid grid_from to grid_to. Works for matrices with second dimension corresponding to grid nodes and for vectors.\n\nwarning: Warning\nMay be slow on non-convex domains. If trybrute==false it may even fail.\n\nwarning: Warning\nCurrently implemented for simplex grids only.\n\n\n\n\n\n","category":"function"},{"location":"cellfinder/#ExtendableGrids.interpolate!","page":"Search and Interpolation","title":"ExtendableGrids.interpolate!","text":"interpolate!(u_to,grid_to, u_from, grid_from;eps=1.0e-14,trybrute=true)\n\nMutating form of interpolate\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#Gmsh-interoperability","page":"Gmsh interoperability","title":"Gmsh interoperability","text":"","category":"section"},{"location":"gmsh/","page":"Gmsh interoperability","title":"Gmsh interoperability","text":"This functionality is in beta stage. Breaking changes for this API are considered non-breaking for the package. Therefore, these functions are not exported yet.","category":"page"},{"location":"gmsh/#API","page":"Gmsh interoperability","title":"API","text":"","category":"section"},{"location":"gmsh/","page":"Gmsh interoperability","title":"Gmsh interoperability","text":"These methods become available via a package extension which is loaded together with  Gmsh.jl. See the general gmsh documentation, the Gmsh reference manual and the Gmsh Julia API source code for  information.","category":"page"},{"location":"gmsh/","page":"Gmsh interoperability","title":"Gmsh interoperability","text":"ExtendableGrids.simplexgrid_from_gmsh\nExtendableGrids.simplexgrid_to_gmsh\nExtendableGrids.mixedgrid_from_gmsh\nExtendableGrids.mixedgrid_to_gmsh\nExtendableGrids.seal!","category":"page"},{"location":"gmsh/#ExtendableGrids.simplexgrid_from_gmsh","page":"Gmsh interoperability","title":"ExtendableGrids.simplexgrid_from_gmsh","text":"simplexgrid_from_gmsh(filename::String; incomplete=false, Tc=Float32, Ti=Int32)\n\nThe msh file is read and a SimplexGrid is created. The mesh can also contain an incomplete grid. For this, the function has to be called with incomplete=true. 'incomplete' means that the grid only consists of nodes and cells, it does not have a boundary. We also do not try to read the physical groups for those grids. Tc is the type of coordinates, Ti is the index type.\n\n\n\n\n\nsimplexgrid_from_gmsh(mod::Module; incomplete=false, Tc=Float32, Ti=Int32)\n\nThe mesh contained in the gmsh module is converted to a SimplexGrid. The mesh can also contain an incomplete grid. For this, the function has to be called with incomplete=true. 'incomplete' means that the grid only consists of nodes and cells, it does not have a boundary. We also do not try to read the physical groups for those grids. Tc is the type of coordinates, Ti is the index type.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGrids.simplexgrid_to_gmsh","page":"Gmsh interoperability","title":"ExtendableGrids.simplexgrid_to_gmsh","text":"simplexgrid_to_gmsh(g::ExtendableGrid; filename::String=\"\")\n\nThe SimplexGrid 'g' is loaded into a gmsh module. If a string (not \"\") is passed via 'filename', the mesh is written into this file.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGrids.mixedgrid_from_gmsh","page":"Gmsh interoperability","title":"ExtendableGrids.mixedgrid_from_gmsh","text":"mixedgrid_from_gmsh(filename::String; Tc=Float32, Ti=Int32)\n\nThe msh file is read and an ExtendableGrid is created. This only works for dim=2 grids and the orientation may be wrong. Tc is the type of coordinates, Ti is the index type.\n\n\n\n\n\nmixedgrid_from_gmsh(mod::Module; Tc=Float32, Ti=Int32)\n\nThe mesh contained in the gmsh module is converted to an ExtendableGrid. Tc is the type of coordinates, Ti is the index type.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGrids.mixedgrid_to_gmsh","page":"Gmsh interoperability","title":"ExtendableGrids.mixedgrid_to_gmsh","text":"mixedgrid_to_gmsh(g::ExtendableGrid; filename::String=\"\")\n\nThe ExtendableGrid 'g' is loaded into a gmsh module. If a string (not \"\") is passed via 'filename', the mesh is written into this file.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGrids.seal!","page":"Gmsh interoperability","title":"ExtendableGrids.seal!","text":"function seal!(grid::ExtendableGrid; bfaceregions=[], encode=true, Ti=Int64)\n\nTake an (simplex-) ExtendableGrid and compute and add the BoundaryFaces. A so called incomplete ExtendableGrid can e.g. be read from an msh file using the Gmsh.jl-extension of the ExtendableGrids package and the function simplexgrid_from_gmsh(filenameString incomplete=true). If a non empty vector is passed as bfaceregions, this vector is used for the 'BFaceRegions'. If bfaceregions is empty, all BoundaryFaces get the region number 1.\n\nFor performance reasons, the faces (=the nodes contained in the face) can be encoded (see the function encode(xVector nnInteger)) to Integers encoding_type. To do this, encode=true is used. But for each encoding_type there is a limit on the number of nodes: \n\n- For Int64  and a 2d grid: 3*10^9 nodes\n- For Int64  and a 3d grid: 2*10^6 nodes\n- For Int128 and a 2d grid: 1.3*10^19 nodes\n- For Int128 and a 3d grid: 5.5*10^12 nodes\n\nIf encode=false is passed, there is no limit (besides the MaxValue of the Integer type used).\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#Internals","page":"Gmsh interoperability","title":"Internals","text":"","category":"section"},{"location":"gmsh/#Gmsh-extension","page":"Gmsh interoperability","title":"Gmsh extension","text":"","category":"section"},{"location":"gmsh/","page":"Gmsh interoperability","title":"Gmsh interoperability","text":"ExtendableGridsGmshExt.gmshfile_to_mixedgrid\nExtendableGridsGmshExt.take_second\nExtendableGridsGmshExt.gmshfile_to_simplexgrid\nExtendableGridsGmshExt.test_gmsh_init\nExtendableGridsGmshExt.mixedgrid_to_gmshfile\nExtendableGridsGmshExt.multiply_indices\nExtendableGridsGmshExt.mod_to_mixedgrid\nExtendableGridsGmshExt.simplexgrid_to_gmshfile\nExtendableGridsGmshExt.simplexgrid_to_mod\nExtendableGridsGmshExt.mod_to_simplexgrid\nExtendableGridsGmshExt.incomplete_mod_to_simplexgrid\nExtendableGridsGmshExt.use_geoms\nExtendableGridsGmshExt.use_vta","category":"page"},{"location":"gmsh/#ExtendableGridsGmshExt.gmshfile_to_mixedgrid","page":"Gmsh interoperability","title":"ExtendableGridsGmshExt.gmshfile_to_mixedgrid","text":"gmshfile_to_mixedgrid(filename::String, Tc, Ti)\n\nThis function just reads an msh file, and creates a gmsh.model and then calls the 'modtomixedgrid' function This function is called in 'mixedgridfromgmsh' Tc is the type of coordinates, Ti is the index type.\n\nThis function initalizes and finalized gmsh.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGridsGmshExt.take_second","page":"Gmsh interoperability","title":"ExtendableGridsGmshExt.take_second","text":"take_second(x)\n\nx is a list of 2-tuples, with an Int as second entry an array of the second entries is returned\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGridsGmshExt.gmshfile_to_simplexgrid","page":"Gmsh interoperability","title":"ExtendableGridsGmshExt.gmshfile_to_simplexgrid","text":"gmshfile_to_simplexgrid(filename::String, Tc, Ti)\n\nThis function reads a .msh or a .geo file, and creates a gmsh.model If it is a .geo file,   gmsh.model.mesh.generate() is called. Finally, it calls the 'modtosimplexgrid' function. This function is called in 'simplexgridfromgmsh' Tc is the type of coordinates, Ti is the index type.\n\nThe function initializes and finalized the gmsh module.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGridsGmshExt.test_gmsh_init","page":"Gmsh interoperability","title":"ExtendableGridsGmshExt.test_gmsh_init","text":"test_gmsh_init()\n\nVery primitive function to test, via a try-catch-block, whether gmsh is already initialized. If not, it will be initialized.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGridsGmshExt.mixedgrid_to_gmshfile","page":"Gmsh interoperability","title":"ExtendableGridsGmshExt.mixedgrid_to_gmshfile","text":"mixedgrid_to_gmshfile(grid::ExtendableGrid, filename::String)\n\nThis function takes a mixed grid, uses 'gridtomod' to create a corresponding gmsh module Then it writes the module to a file\n\ngrid[CellNodes] must be a VariableTargetAdjacency structure This function initializes and finalized gmsh.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGridsGmshExt.multiply_indices","page":"Gmsh interoperability","title":"ExtendableGridsGmshExt.multiply_indices","text":"multiply_indices(indices, n)\n\nfor n=3: [i, j, ..., k], 3 -> [3i-2, 3i-1, 3i, 3j-1, 3j-2, 3j, ..., 3k-2, 3k-1, 3k] in general: [i, j, ..., k], n -> [ni-(n-1), ni-(n-2), ..., ni, n*j-(n-1), ...] This function can be used, if you have the indices of cells, and you want to get all their nodes, but the nodes are stored in one list for all cells:  [node1ofcell1, node2ofcell1, ... nodenofcell1, node1ofcell2, ...]\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGridsGmshExt.mod_to_mixedgrid","page":"Gmsh interoperability","title":"ExtendableGridsGmshExt.mod_to_mixedgrid","text":"mod_to_mixedgrid(model::Module, Tc, Ti)\n\nFunction that tries to create a (mixed-) ExtendableGrid from a gmsh.model. Model has to be a gmsh.model. (This function has to be called with an initialized gmsh environment). This function is called in 'mixedgridfromgmsh'. Tc is the type of coordinates, Ti is the index type.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGridsGmshExt.simplexgrid_to_gmshfile","page":"Gmsh interoperability","title":"ExtendableGridsGmshExt.simplexgrid_to_gmshfile","text":"function simplexgrid_to_gmshfile(grid::ExtendableGrid, filename::String)\n\nThis function takes a simplexgrid, uses 'gridtomod' to create a corresponding gmsh module Then it writes the module to a file.\n\nThis function initalizes and finalized gmsh.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGridsGmshExt.simplexgrid_to_mod","page":"Gmsh interoperability","title":"ExtendableGridsGmshExt.simplexgrid_to_mod","text":"grid_to_mod(grid::ExtendableGrid)\n\nThis function writes an ExtendableGrid into a gmsh module. (This function has to be called with an initialized gmsh environment) At the moment, this function can only be used from the outside via 'write_gmsh', where the newly created gmsh module is written into a msh file.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGridsGmshExt.mod_to_simplexgrid","page":"Gmsh interoperability","title":"ExtendableGridsGmshExt.mod_to_simplexgrid","text":"mod_to_grid(model::Module, Tc, Ti)\n\nFunction that tries to create an (simplex-) ExtendableGrid from a gmsh.model. Model has to be a gmsh.model. (This function has to be called with an initialized gmsh environment). This function is called in 'simplexgridfromgmsh'. Tc is the type of coordinates, Ti is the index type.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGridsGmshExt.incomplete_mod_to_simplexgrid","page":"Gmsh interoperability","title":"ExtendableGridsGmshExt.incomplete_mod_to_simplexgrid","text":"incomplete_mod_to_simplexgrid(model::Module, Tc, Ti)\n\nLoads an incomplete mesh from a msh file. Then converts into an ExtendableGrids. 'incomplete' in this context means the boundary is missing. With the 'ExtendableGrids.seal!(grid::ExtendableGrid)' the boundary can be added. Tc is the type of coordinates, Ti is the index type.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGridsGmshExt.use_geoms","page":"Gmsh interoperability","title":"ExtendableGridsGmshExt.use_geoms","text":"use_geoms(cellgeoms, ids)\n\nIf cellgeoms would just be an array/vector, the result would be equivalent to cellgeoms[ids].\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGridsGmshExt.use_vta","page":"Gmsh interoperability","title":"ExtendableGridsGmshExt.use_vta","text":"use_vta(VTA, col_ids, num)\n\nIf VTA were a matrix, the result would be equivalent to VTA[:, col_ids]. Each column of the VTA contains the nodes of one cell.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#seal!-method","page":"Gmsh interoperability","title":"seal! method","text":"","category":"section"},{"location":"gmsh/","page":"Gmsh interoperability","title":"Gmsh interoperability","text":"ExtendableGrids.faces_of_ndim_simplex\nExtendableGrids.assemble_bfaces_direct\nExtendableGrids.decode\nExtendableGrids.encode\nExtendableGrids.faces_of_ndim_simplex_direct\nExtendableGrids.assemble_bfaces","category":"page"},{"location":"gmsh/#ExtendableGrids.faces_of_ndim_simplex","page":"Gmsh interoperability","title":"ExtendableGrids.faces_of_ndim_simplex","text":"function faces_of_ndim_simplex(x::Vector, dim::Integer, nn::Integer)\n\nReturn all faces of a n-dim simplex. The orientation is not guaranteed to be right. x contains the nodes of the simplex. nn is the total number of nodes. The faces (=the nodes contained in the face), are encoded to Integers (of nn's type).\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGrids.assemble_bfaces_direct","page":"Gmsh interoperability","title":"ExtendableGrids.assemble_bfaces_direct","text":"function assemble_bfaces_direct(simplices, dim, Ti)\n\nAssemble the BoundaryFaces corresponding to the simplices passed. In this function, the faces are not encoded. This may make sense for grids with many nodes. For smaller grids it can lead to performance losses. simplices is a (dim+1) x number cells matrix and nn is the total number of nodes. We can not guarantee, that the orientation of the BoundaryFaces is correct.  \n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGrids.decode","page":"Gmsh interoperability","title":"ExtendableGrids.decode","text":"function decode(y::Integer, nn::Integer, dim::Integer)\n\nDecode y to the vector x. x has the length dim. The en/-decoding is similar to using the base-nn number system. For details of the encoding, see the documentation of the function encode.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGrids.encode","page":"Gmsh interoperability","title":"ExtendableGrids.encode","text":"function encode(x::Vector, nn::Integer)\n\nEncode th vector x into an Int y. The en/-decoding is similar to using the base-nn number system. Example: x₁ x₂ x₃  (x₁-1) + (x₂-1)*nn + (x₃-1)*nn²``\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGrids.faces_of_ndim_simplex_direct","page":"Gmsh interoperability","title":"ExtendableGrids.faces_of_ndim_simplex_direct","text":"function faces_of_ndim_simplex(x::Vector, dim::Integer, nn::Integer)\n\nReturn all faces of a n-dim simplex. The orientation is not guaranteed to be right. x contains the nodes of the simplex. nn is the total number of nodes. The faces (=the nodes contained in the face), are not encoded to Integers.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGrids.assemble_bfaces","page":"Gmsh interoperability","title":"ExtendableGrids.assemble_bfaces","text":"function assemble_bfaces(simplices, dim, nn, Ti)\n\nAssemble the BoundaryFaces corresponding to the simplices passed. In this function, the faces are encoded for performance reasons. If a large grid with many nodes is used, Ti has to be chosen accordingly (e.g. Int128), or encode=false has to be passed to seal!. simplices is a (dim+1) x number cells matrix and nn is the total number of nodes. We can not guarantee, that the orientation of the BoundaryFaces is correct.  \n\n\n\n\n\n","category":"function"},{"location":"changes/#Changelog","page":"Changes","title":"Changelog","text":"","category":"section"},{"location":"changes/#[1.7.0]-2024-06-17","page":"Changes","title":"[1.7.0] - 2024-06-17","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Partitioning for multithreading\nMetis extension","category":"page"},{"location":"changes/#[1.6.1]-2024-06-07","page":"Changes","title":"[1.6.1] - 2024-06-07","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Drop support of Julia 1.6. Minimum Julia version is 1.9\nTetGen + Triangulate extensions\npng instead of svg in docs","category":"page"},{"location":"changes/#[1.5.1]-2024-05-06","page":"Changes","title":"[1.5.1] - 2024-05-06","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Grid consistency check\nGmsh 0.3","category":"page"},{"location":"changes/#[1.4.0]-2024-03-21","page":"Changes","title":"[1.4.0] - 2024-03-21","text":"","category":"section"},{"location":"changes/#Features","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Move binnedpointlist to ExtendableGrids\nNew grid glueing  algorithm using BinnedPointList\nFix docs, test\nMerge pull request #42 from j-fu/mvbinned","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Move binned pointlist over here and use it for glueing","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Update! function to trigger reinstantioation of grid components; instantiate of Volumes components and FaceNormals and EdgeTangents keep existing arrays.\nMerge pull request #41 from chmerdon/master","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Reinstantiation of CellVolumes, FaceNormals etc.","category":"page"},{"location":"changes/#[1.3.2]-2024-03-08","page":"Changes","title":"[1.3.2] - 2024-03-08","text":"","category":"section"},{"location":"changes/#Features-2","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Fix documentation, all docstrings in output\nUpdate ci for apple silicon\nAdd docstrings for commongrids\nAdd Aqua.jl tests\nSimplexGridFactory isn't differently licensed\nBump patch version","category":"page"},{"location":"changes/#[1.3.1]-2024-02-20","page":"Changes","title":"[1.3.1] - 2024-02-20","text":"","category":"section"},{"location":"changes/#Features-3","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Fix subgrid coordinate system for boundary grids (#38)\nfix subgrid coordinate system for boundary grids\nuse ExampleJuggler v2 (no Pluto dependency due to extensions)","category":"page"},{"location":"changes/#[1.3.0]-2024-02-05","page":"Changes","title":"[1.3.0] - 2024-02-05","text":"","category":"section"},{"location":"changes/#Features-4","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Merge branch 'master' of https://github.com/chmerdon/ExtendableGrids.jl\nNew grid components ParentGridRelation, FaceParents, CellParents, BFaceParents,","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"some of them are now directly set during subgrid or refinement routines (todo: set BFaceParents also in refinements)","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Small fix\nSmall fix\nAdded BFaceParents to all refinement routines and some tests\nRenamed NodeInParent to NodeParents, added a deprecated warning on this\nNew grid components ParentGridRelation, FaceParents, CellParents, BFaceParents,","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"some of them are now directly set during subgrid or refinement routines (todo: set BFaceParents also in refinements)","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Small fix\nSmall fix\nAdded BFaceParents to all refinement routines and some tests\nRenamed NodeInParent to NodeParents, added a deprecated warning on this\nMerge branch 'master' of github.com:j-fu/ExtendableGrids.jl","category":"page"},{"location":"changes/#[1.2.3]-2024-01-19","page":"Changes","title":"[1.2.3] - 2024-01-19","text":"","category":"section"},{"location":"changes/#Features-5","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Fix for subgrid in case there is empty boundary data in the parent grid (or probably also when the subgrid lies completely in the interior)\nModified the subgrid+extrusion test a bit to test if a subgrid for a completely interior region works (and it only does with the previous modifications)\nFix for subgrid in case there is empty boundary data  (#36)\nfix for subgrid in case there is empty boundary data in the parent grid (or probably also when the subgrid lies completely in the interior)\nmodified the subgrid+extrusion test a bit to test if a subgrid for a completely interior region works (and it only does with the previous modifications)\nBump patch version","category":"page"},{"location":"changes/#[1.2.2]-2023-11-29","page":"Changes","title":"[1.2.2] - 2023-11-29","text":"","category":"section"},{"location":"changes/#Features-6","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Add more gmsh stuff\nhandle geo files\nallow for simplexgrid(\"my.msh\") and simplexgrid(\"my.geo\")\nallow for `write(\"my.msh\",grid)\nfile handling with gmsh initializes and finalizes\nBump version","category":"page"},{"location":"changes/#[1.2.1]-2023-11-28","page":"Changes","title":"[1.2.1] - 2023-11-28","text":"","category":"section"},{"location":"changes/#Features-7","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Bugfixes for gmsh extension\nhandle node tags properly\nadd more examples from gmsh docs","category":"page"},{"location":"changes/#[1.2.0]-2023-11-23","page":"Changes","title":"[1.2.0] - 2023-11-23","text":"","category":"section"},{"location":"changes/#Features-8","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Gmsh extension3 (#34)\nUpdate ExtendableGridsGmshExt.jl\nAdd the seal function","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Computes the boundary faces of an incomplete simplexgrid and adds them to it","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"simplexgrid  + mixedgrid functions for the gmsh extension are defined\nadd tests with different types (of indices & coordinates) for gmsh Y ExtendableGrids\nadd gmsh geometry description test\nDocument the gmsh stuff","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Co-authored-by: Jürgen Fuhrmann <juergen-fuhrmann@web.de>","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Use ExampleJuggler (#35)\nmoved tests to examplejuggler\nmove documentation to examplejuggler\nAdd gmsh example\nSmall readme+docs update\nAdd J. Taraz to author lists","category":"page"},{"location":"changes/#[1.1.0]-2023-07-25","page":"Changes","title":"[1.1.0] - 2023-07-25","text":"","category":"section"},{"location":"changes/#Features-9","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Update Project.toml","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"change Project.toml to incorporate the extension","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Create ExtendableGridsGmshExt.jl\nUpdate ExtendableGridsGmshExt.jl","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"upload the (gmsh-) extension code","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Update simplexgrid.jl","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"include function definitions with implementations in the gmsh extension","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Gmsh-files for tests\n(g)msh-files for the test of the extension\nDelete sto_2d.msh\nDelete sto_3d.msh\nUpdate runtests.jl","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"added the tests of the gmsh extension","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Update Project.toml","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"add dependencies for the gmsh extension","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Update Project.toml\nUpdate runtests.jl\nMerge pull request #32 from jotaraz/master","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"gmsh ext","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Add requires for 1.6\nRemove assignment to gms.model for Julia <1.9\nRemove dummy simplexgrid(module)\nBump version\nMerge pull request #33 from j-fu/gmsh-extension2","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"add requires for 1.6","category":"page"},{"location":"changes/#[1.0.0]-2023-07-22","page":"Changes","title":"[1.0.0] - 2023-07-22","text":"","category":"section"},{"location":"changes/#Features-10","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"GeometryGroups (#27)\nnew type CellGeometryGroups that collect all cells of same CellGeometry as ordered in UniqueCellGeometries\nview for VariableTargetAdjacency, less allocation in FaceNodes for mixed geometries","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Co-authored-by: Christian Merdon <merdon@wias-berlin.de>","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Allow non-leaf types in ElementGeometries\nNew type CellGeometryGroups that collect all cells of same CellGeometry as ordered in UniqueCellGeometries\nAdded also FaceGeometryGroups etc. and assembly helpers\nInit BEdgeRegions with an array, so that test for bedgemask works again\nGeometryGroups > AssemblyGroups\nSome small corrections, view for VariableTargetAdjacency, less allocation in FaceNodes for mixed geometries\nSome small improvements\nMerge pull request #31 from j-fu/geometry_groups","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"some small changes","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Merge branch 'master' into quadmeshes\nMerge pull request #30 from j-fu/quadmeshes","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Prepare for  quadrilateral and cuboidal elements","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Set cairomakie invisible in tests\nSet version to 1.0 for better semver","category":"page"},{"location":"changes/#[0.9.17]-2023-02-10","page":"Changes","title":"[0.9.17] - 2023-02-10","text":"","category":"section"},{"location":"changes/#Features-11","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Fix print_tree calls\nSorting coordinates of 1D subgrids\nUse CairoMakie for plotting tests & docs\nMerge pull request #22 from j-fu/sort1dsubgrids","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Sort 1d subgrids","category":"page"},{"location":"changes/#[0.9.16]-2022-11-30","page":"Changes","title":"[0.9.16] - 2022-11-30","text":"","category":"section"},{"location":"changes/#Features-12","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Remove allocation regression in Julia 1.9 - return Matrices as local_celledgenodes etc. instead of adjoints","category":"page"},{"location":"changes/#[0.9.15]-2022-10-22","page":"Changes","title":"[0.9.15] - 2022-10-22","text":"","category":"section"},{"location":"changes/#Features-13","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Cleanup type handling for simplexgrid constructors, 0.9.15\nFixes stackoverflow error when calling simplexgrid with arrays of different index types\nDetect index types from CellNode arrays\nreplace collectorassign by convert\nadd bregions, cellregion constructor to tensor grid constructor\nVersion bump\nFix CI for 1.6\nFix CI for 1.6 - again","category":"page"},{"location":"changes/#[0.9.14]-2022-10-19","page":"Changes","title":"[0.9.14] - 2022-10-19","text":"","category":"section"},{"location":"changes/#Features-14","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"BFaceRegions in grid after uniform_refine are still VectorOfConstants if BFaceRegions in source grid has been VectorOfConstants\nIntroduce barrier in volume calculation (#19)","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Bump version","category":"page"},{"location":"changes/#[0.9.13]-2022-09-13","page":"Changes","title":"[0.9.13] - 2022-09-13","text":"","category":"section"},{"location":"changes/#Features-15","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Fix unit test for writevtk\nCreate Invalidations.yml (#16)\nCreate Invalidations.yml","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"This is based on https://github.com/julia-actions/julia-invalidations. Adding such checks came up in https://discourse.julialang.org/t/potential-performance-regressions-in-julia-1-8-for-special-un-precompiled-type-dispatches-and-how-to-fix-them/86359. I suggest to add this check here since this package is widely used as a dependency.","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"See also SciML/MuladdMacro.jl#26 and SciML/MuladdMacro.jl#29","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Missing bracket (#18)","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Bump version, allow AbstractTrees 0.4","category":"page"},{"location":"changes/#[0.9.12]-2022-06-23","page":"Changes","title":"[0.9.12] - 2022-06-23","text":"","category":"section"},{"location":"changes/#Features-16","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Piecewise linear interpolation between simplexgrids","category":"page"},{"location":"changes/#[0.9.11]-2022-06-21","page":"Changes","title":"[0.9.11] - 2022-06-21","text":"","category":"section"},{"location":"changes/#Features-17","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Speed up of hot loops in  bfacemask! and cellmask!","category":"page"},{"location":"changes/#[0.9.10]-2022-06-16","page":"Changes","title":"[0.9.10] - 2022-06-16","text":"","category":"section"},{"location":"changes/#Features-18","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Bregion numbers can now be functions of the current region, or zero to erase","category":"page"},{"location":"changes/#[0.9.9]-2022-06-16","page":"Changes","title":"[0.9.9] - 2022-06-16","text":"","category":"section"},{"location":"changes/#Features-19","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Bugfix for 3D rect!","category":"page"},{"location":"changes/#[0.9.8]-2022-06-15","page":"Changes","title":"[0.9.8] - 2022-06-15","text":"","category":"section"},{"location":"changes/#Features-20","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Bump to 0.9.8 - missed some commits","category":"page"},{"location":"changes/#[0.9.7]-2022-06-15","page":"Changes","title":"[0.9.7] - 2022-06-15","text":"","category":"section"},{"location":"changes/#Features-21","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Fix superfluous corner triangles in subgrid generation\nAdded rect! to regionedit - place surface info into rectangular grid","category":"page"},{"location":"changes/#[0.9.6]-2022-05-13","page":"Changes","title":"[0.9.6] - 2022-05-13","text":"","category":"section"},{"location":"changes/#Features-22","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Added barycentric refinement for Tetrahedron3D and some tests for uniform and barycentric refinement","category":"page"},{"location":"changes/#[0.9.5]-2022-03-27","page":"Changes","title":"[0.9.5] - 2022-03-27","text":"","category":"section"},{"location":"changes/#Features-23","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Improve glue performance\nallow to restrict tested regions\nremoved allocations in main loop","category":"page"},{"location":"changes/#[0.9.4]-2022-03-24","page":"Changes","title":"[0.9.4] - 2022-03-24","text":"","category":"section"},{"location":"changes/#Features-24","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Added FaceEdgeSigns, version bump","category":"page"},{"location":"changes/#[0.9.3]-2022-03-23","page":"Changes","title":"[0.9.3] - 2022-03-23","text":"","category":"section"},{"location":"changes/#Features-25","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Added function for writing grid structure to vtk_write (#12)\nAdded function for writing grid structure to io.jl","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"The writing of the VTK files uses the WriteVTK.jl package. Hence, it was added as dependency. In addition to the grid structure, point, cell, or field data can be written to the file.","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"julia1.6 now required, added test (needs SHA hash comparison to test Project.toml)","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Co-authored-by: chmerdon <57663257+chmerdon@users.noreply.github.com>","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Update ci.yml","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"update to new minimum julia version dependency","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Update Project.toml","category":"page"},{"location":"changes/#[0.9.2]-2022-03-22","page":"Changes","title":"[0.9.2] - 2022-03-22","text":"","category":"section"},{"location":"changes/#Features-26","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Fix for node ordering in tensor grid constructor such that no negative cell volumes occur","category":"page"},{"location":"changes/#[0.9.1]-2022-02-21","page":"Changes","title":"[0.9.1] - 2022-02-21","text":"","category":"section"},{"location":"changes/#Features-27","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Some bugfixes for unionizing update, version bump","category":"page"},{"location":"changes/#[0.9.0]-2022-02-18","page":"Changes","title":"[0.9.0] - 2022-02-18","text":"","category":"section"},{"location":"changes/#Features-28","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Unionize abstract types (#13)","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"This relies on the built-in union split of Julia which seems to have no union size constraint anymore. This may remove some allocations...","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Use \"ElementGeomtries\" – union of Geometry leaf types – as eltype for CellGeometries,BFaceGeomtries\nSimilar with CoordinateSystems.\nfixed UniqueBFaceGeometries etc, reduced allocations in ItemVolumes instantiations (dispatch on CoordinateSystem seems to cause remaining allocations)\nuse SVector for storing intermediate vector data\nAdded more typestable getindex methods.\nuse length of cx  in cellfinder instead of x as length of x might not match)","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Co-authored-by: Christian Merdon <merdon@localhost.localdomain>","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Version bump","category":"page"},{"location":"changes/#[0.8.11]-2021-12-06","page":"Changes","title":"[0.8.11] - 2021-12-06","text":"","category":"section"},{"location":"changes/#Features-29","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Glue and simplexgrid(xygrid, zcoord) now use Cint indices.","category":"page"},{"location":"changes/#[0.8.10]-2021-11-13","page":"Changes","title":"[0.8.10] - 2021-11-13","text":"","category":"section"},{"location":"changes/#Features-30","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Test against tol for lmismatch in geomspace","category":"page"},{"location":"changes/#[0.8.9]-2021-11-10","page":"Changes","title":"[0.8.9] - 2021-11-10","text":"","category":"section"},{"location":"changes/#Features-31","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Fix missing CoordinateSystem instantiation for subgrid","category":"page"},{"location":"changes/#[0.8.8]-2021-11-03","page":"Changes","title":"[0.8.8] - 2021-11-03","text":"","category":"section"},{"location":"changes/#Features-32","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Volume of Vertex0D set to 1\nSwitch off plotting testset on windows system for now\nVersion bump","category":"page"},{"location":"changes/#[0.8.7]-2021-10-21","page":"Changes","title":"[0.8.7] - 2021-10-21","text":"","category":"section"},{"location":"changes/#Features-33","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Added ringsector2d","category":"page"},{"location":"changes/#[0.8.6]-2021-10-21","page":"Changes","title":"[0.8.6] - 2021-10-21","text":"","category":"section"},{"location":"changes/#Features-34","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Modify 2D x Z tensorproduct API: make cell, bottom and top regions from","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"offsets of 2D cellregions","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Bfacemask! for 3D, introduce allow_new flag","category":"page"},{"location":"changes/#[0.8.5]-2021-10-20","page":"Changes","title":"[0.8.5] - 2021-10-20","text":"","category":"section"},{"location":"changes/#Features-35","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Tensor product grid2d x coordZ","category":"page"},{"location":"changes/#[0.8.4]-2021-10-20","page":"Changes","title":"[0.8.4] - 2021-10-20","text":"","category":"section"},{"location":"changes/#Features-36","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Docstring for VoronoiFaceCenters\nAdd glue method for grids\nRemoved Base.RefValues from L2GTransformer struct and made it mutable (immutability seems to give no benefit here)\nMerge branch 'master' of github.com:j-fu/ExtendableGrids.jl","category":"page"},{"location":"changes/#[0.8.3]-2021-10-13","page":"Changes","title":"[0.8.3] - 2021-10-13","text":"","category":"section"},{"location":"changes/#Features-37","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Add tests for geomspace, make assertion warnings more clear\nDon't use yet X[begin]\nSome more geomspace tweaks\nCalculate VoronoiFaceCenters, take in tricircumcenter!\nAdd voronoi.jl","category":"page"},{"location":"changes/#[0.8.2]-2021-10-07","page":"Changes","title":"[0.8.2] - 2021-10-07","text":"","category":"section"},{"location":"changes/#Features-38","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Start to sort out documentation\nRemove plotting test\nLess allocations in instantiation of EdgeNodes\nLess allocations in instantiation of FaceNormals and EdgeTangents, converted some Float64 to Tc\nSome tweaks for geomspace\nMerge branch 'master' of github.com:j-fu/ExtendableGrids.jl\nMerge branch 'master' of https://github.com/j-fu/ExtendableGrids.jl\nReduced allocations in all mesh refinements, last remnants of GridAdjacencyTypes erased and replaced by Adjacency","category":"page"},{"location":"changes/#[0.8.1]-2021-10-06","page":"Changes","title":"[0.8.1] - 2021-10-06","text":"","category":"section"},{"location":"changes/#Features-39","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Nnodesforgeometry/nfacesforgeometry/nedgesforgeometry erased/merged into numnodes/numfaces/numedges that are now residing in shapespecs.jl, edges are always Edge1D (adjusted instantiation of EdgeNodes in derived.jl accordingly), erased GridAdjacencyTypes, added enum consistency tests also for Parallelepiped3D\nActivated L2GTransfer, AssemblyTypes, CellFinder (moved from GradientRobustMultiPhysics) and respective tests; renamed BFaces to BFaceFaces and BEdges to BEdgeEdges\nVersion 0.8.1\nCh Merdon as author\nSet EdgeGeometries in instantiation of EdgesNodes in 1D and 2D\nMerge branch 'master' of https://github.com/j-fu/ExtendableGrids.jl\nMerge branch 'master' of github.com:j-fu/ExtendableGrids.jl","category":"page"},{"location":"changes/#[0.8.0]-2021-10-05","page":"Changes","title":"[0.8.0] - 2021-10-05","text":"","category":"section"},{"location":"changes/#Features-40","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Phase 1 Transfer of gridstuff from GradienRobustMultiPhysics (#11)\nPhase 1 Transfer of gridstuff from GradienRobustMultiPhysics\nBump  version","category":"page"},{"location":"changes/#[0.7.9]-2021-07-09","page":"Changes","title":"[0.7.9] - 2021-07-09","text":"","category":"section"},{"location":"changes/#Features-41","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Added boundary edge regions (#10)\nAdded boundary edge regions\nExtended constructor for simplexgrid\nFixed missing assignment of boundary edge node adjacency","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Co-authored-by: Matthias Liero <matthias.liero@wias-berlin.de>","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Bump version","category":"page"},{"location":"changes/#[0.7.8]-2021-07-02","page":"Changes","title":"[0.7.8] - 2021-07-02","text":"","category":"section"},{"location":"changes/#Features-42","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Bugfix for BFaceCells, relax parameter types in simplexgrid() constructor","category":"page"},{"location":"changes/#[0.7.7]-2021-06-15","page":"Changes","title":"[0.7.7] - 2021-06-15","text":"","category":"section"},{"location":"changes/#Features-43","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Type-annotated some methods\nCompute adjacency between boundary faces and edges. (#8)\nCompute adjacency between boundary faces and edges.\nAdded missing methods","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Co-authored-by: Matthias Liero <matthias.liero@wias-berlin.de>","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Merge branch 'master' of github.com:j-fu/ExtendableGrids.jl\nBump patch version","category":"page"},{"location":"changes/#[0.7.6]-2021-03-31","page":"Changes","title":"[0.7.6] - 2021-03-31","text":"","category":"section"},{"location":"changes/#Features-44","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"J fu bfnormals (#7)","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Enable outflow bc in VoronoiFVM","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Create BFaceNodes, BFaceNormals\nsparsematrix <-> adjacency handling\nRemove ExtendableSparse as Dependency\nRelax some type constraints for simplexgrid\nbump version\nOops: remove GridVisiualize from Project.toml","category":"page"},{"location":"changes/#[0.7.5]-2021-03-30","page":"Changes","title":"[0.7.5] - 2021-03-30","text":"","category":"section"},{"location":"changes/#Features-45","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Bump patch version, Allow for ExtendableSparse 0.4","category":"page"},{"location":"changes/#[0.7.4]-2021-01-12","page":"Changes","title":"[0.7.4] - 2021-01-12","text":"","category":"section"},{"location":"changes/#Features-46","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Factored out plotting","category":"page"},{"location":"changes/#[0.7.3]-2021-01-10","page":"Changes","title":"[0.7.3] - 2021-01-10","text":"","category":"section"},{"location":"changes/#Features-47","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Fix typo (colstaert)","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"change alpha default for surfaces.","category":"page"},{"location":"changes/#[0.7.2]-2021-01-09","page":"Changes","title":"[0.7.2] - 2021-01-09","text":"","category":"section"},{"location":"changes/#Features-48","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Reorganization: GridVisualize as submodule\nRenamed:","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"GridPlotContext -> GridVisualizer gridplot -> visualize SubPlotContext -> SubVis","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"More renames for passing test\nBump version","category":"page"},{"location":"changes/#[0.7.1]-2021-01-09","page":"Changes","title":"[0.7.1] - 2021-01-09","text":"","category":"section"},{"location":"changes/#Features-49","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Gridplot checks with VoronoiFVM\nDetailed checks for plotting with VoronoiFVM\nPluto examples in experimental","category":"page"},{"location":"changes/#[0.7.0]-2021-01-07","page":"Changes","title":"[0.7.0] - 2021-01-07","text":"","category":"section"},{"location":"changes/#Features-50","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Renamed plot->gridplot,  use AbstractPlotting >0.15 (#5)","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Renamed plot->gridplot,  use AbstractPlotting >0.15","category":"page"},{"location":"changes/#[0.6.3]-2021-01-06","page":"Changes","title":"[0.6.3] - 2021-01-06","text":"","category":"section"},{"location":"changes/#Features-51","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Fix use of extrema in bbox\nColor handling via Colors.jl and ColorSchemes.jl\nAdded rosetta.jl to experimental test examples\nSave method for plot context\nLower expectation to  coverage\nFix codecov\nFix codecov\nLast developments before switching to AbstratPlotting 0.15 (#4)","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Color handling via Colors.jl and ColorSchemes.jl In addition:","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"fix use of extrema in bbox\ncolor handling via Colors.jl and ColorSchemes.jl\nadded rosetta.jl to experimental test examples\nsave method for plot context","category":"page"},{"location":"changes/#[0.6.2]-2021-01-01","page":"Changes","title":"[0.6.2] - 2021-01-01","text":"","category":"section"},{"location":"changes/#Features-52","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Pluto tests, MeshCat (#3)\nmarching tets et al can directly write into GeometryBasics compatible arrays\nadd experimental meshcat implementation (3D only)\ndon't run plotting tests on apple\nBump version","category":"page"},{"location":"changes/#[0.6.1]-2020-12-31","page":"Changes","title":"[0.6.1] - 2020-12-31","text":"","category":"section"},{"location":"changes/#Features-53","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Assert non-empty pointlist in simplexgrid\n3D Makie plotting interaction via keyboard\nsliders would eat up screen real estate\nmiddle mouse probably not available everywere\nup/down for fine moving and pgup/pgdown for coarse seems to be ok\nadded title and status to 3d scene\nNew subplot handling working with PyPlot\nMakie now running with multiscene\nFixed allocations in simplexgrid\nImplementations (sometimes initial) for grid and grid,func in 1D, 2D, 3D\nSupport  Makie, PyPlot, VTKView (VTKView without grid 1D)\nAt least temporarily drop support of Plots\nSubplot handling: examples, docs\nRemove dependency on Observables\nAdded grid writing\nfixed initializaion bug in tokenstream\ntry to increase codecov\nDon't use cleanup in tempname()\nFix definition of extrema\nTry to increase coverage:","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"add PyPlot to test dependency, test pyplot plotting","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Add  project.toml for test\nTry to set env for runtestes\nFix project.toml","category":"page"},{"location":"changes/#[0.6.0]-2020-12-24","page":"Changes","title":"[0.6.0] - 2020-12-24","text":"","category":"section"},{"location":"changes/#Features-54","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Trigger TagBot on issue_comment instead of cron: https://discourse.julialang.org/t/ann-required-updates-to-tagbot-yml/49249\nAdd 3D tensorgrid creation\nDocumentation overhaul, fixed simplexgrid bug","category":"page"},{"location":"changes/#[0.5.8]-2020-12-20","page":"Changes","title":"[0.5.8] - 2020-12-20","text":"","category":"section"},{"location":"changes/#Features-55","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Use codecov.yml instead of switching off codecov\nBugfix in adjacency\nAdd test for subgrid","category":"page"},{"location":"changes/#[0.5.7]-2020-12-14","page":"Changes","title":"[0.5.7] - 2020-12-14","text":"","category":"section"},{"location":"changes/#Features-56","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Lots of small fixes","category":"page"},{"location":"changes/#[0.5.6]-2020-12-12","page":"Changes","title":"[0.5.6] - 2020-12-12","text":"","category":"section"},{"location":"changes/#Features-57","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Use backlight for isosurfaces and planes.","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Be sure to have https://github.com/JuliaPlots/GLMakie.jl/commit/05220480a3e79c254f538ba46a38d437598c874e in GLMakie >=1.19","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Fix small glitches + version bump","category":"page"},{"location":"changes/#[0.5.5]-2020-12-12","page":"Changes","title":"[0.5.5] - 2020-12-12","text":"","category":"section"},{"location":"changes/#Features-58","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Figured out with how to have changing mesh and changing function at once, see","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"https://github.com/JuliaPlots/Makie.jl/issues/778#issuecomment-742397119","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"First reasonable 3D function plotting","category":"page"},{"location":"changes/#[0.5.4]-2020-12-09","page":"Changes","title":"[0.5.4] - 2020-12-09","text":"","category":"section"},{"location":"changes/#Features-59","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Refactor plotting\ngeneric mesh visibility extraction  for grid plot moved from makie  to common\none loop for all materials.\nFirst reasonable 3D Grid plots  with PyPlot\nRotation kwargs (work only for pyplot)","category":"page"},{"location":"changes/#[0.5.3]-2020-12-07","page":"Changes","title":"[0.5.3] - 2020-12-07","text":"","category":"section"},{"location":"changes/#Features-60","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Rename ci\nAdded DOCUMENTER_KEY to TagBot.yml\nInteractive Makie grid plot for 3D simplex grids\nRemove coverage test from workflow for the time being","category":"page"},{"location":"changes/#[0.5.2]-2020-12-05","page":"Changes","title":"[0.5.2] - 2020-12-05","text":"","category":"section"},{"location":"changes/#Features-61","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Thank you travis and bye bye\nThank you travis and bye bye\nremoved .travis.yml","category":"page"},{"location":"changes/#[0.5.1]-2020-12-04","page":"Changes","title":"[0.5.1] - 2020-12-04","text":"","category":"section"},{"location":"changes/#Features-62","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Firsts steps to makie grid plotting","category":"page"},{"location":"changes/#[0.5.0]-2020-12-04","page":"Changes","title":"[0.5.0] - 2020-12-04","text":"","category":"section"},{"location":"changes/#Features-63","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Change edge plotting default to true\nRelaxs type constraints for geomspace\nFirst step to 3D grid visualization\nUpdate readme & bump version","category":"page"},{"location":"changes/#[0.4.2]-2020-10-24","page":"Changes","title":"[0.4.2] - 2020-10-24","text":"","category":"section"},{"location":"changes/#Features-64","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Moved edge creation from VoronoiFVM","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"This currently creates a dependency on ExtendableSparse which should be replaced some time.","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Don't print in show() methods!\nHandle boundaries when creating bulk subgrid\nSome fixes for pyplot in Pluto notebooks.","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Don't call PyPlot.show() and PyPlot.pause(), as this must be handeled by the user.","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Bfacemask! now allows to add new boundary facets in 2D\nFix show again\nFixing docs\nV0.4.2\nFix compat","category":"page"},{"location":"changes/#[0.4.1]-2020-09-24","page":"Changes","title":"[0.4.1] - 2020-09-24","text":"","category":"section"},{"location":"changes/#Features-65","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Documentation fix","category":"page"},{"location":"changes/#[0.4.0]-2020-09-23","page":"Changes","title":"[0.4.0] - 2020-09-23","text":"","category":"section"},{"location":"changes/#Features-66","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Plotting of GridFactory showing input and output (PyPlot)\nfirst steps of Makie plotting\nRebuild of plotting architecture\ndispatching via plotter type\nPlotterContext holds state of plot, allowing reuse or update (e.g. for Makie), see examples/plotlooptest.jl\nFirst plots with  Makie & WGLMakie\nIntroduce kwargs for plotting\nPlotloop stuff\nFine tuned and commentes plotting stuff\nHelp mechanism for flags\nTest for two figure arrangements in one plot  -> future layout stuff\nFix travis\nSwitch to travis-ci.com\nMoving GridFactory to SimplexGridFactory.SimplexGridBuilder","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"(mainly for licensing reasons)","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Removed dependency on Triangulate\nAdded MIT License\nMentioned accssibility of Triangle via SimplexGridFactory\nVersion 0.4.0","category":"page"},{"location":"changes/#[0.3.0]-2020-09-04","page":"Changes","title":"[0.3.0] - 2020-09-04","text":"","category":"section"},{"location":"changes/#Features-67","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"First working steps to GridFactory\nImproved GridFactory","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Added Examples to docs","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Git-added missing files\nV0.3: added GridFactory, Examples","category":"page"},{"location":"changes/#[0.2.3]-2020-07-17","page":"Changes","title":"[0.2.3] - 2020-07-17","text":"","category":"section"},{"location":"changes/#Features-68","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Version 0.2.3 using Triangulate 0.5\nFixed issue #1","category":"page"},{"location":"changes/#[0.2.2]-2020-05-01","page":"Changes","title":"[0.2.2] - 2020-05-01","text":"","category":"section"},{"location":"changes/#Features-69","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Add [XYZ]Cordinates to grid if they have been there.","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"This allows rectangular grid plotting (e.g. with Plots)","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Fixed some plotting, show(grid)\nPatch version bump","category":"page"},{"location":"changes/#[0.2.1]-2020-04-28","page":"Changes","title":"[0.2.1] - 2020-04-28","text":"","category":"section"},{"location":"changes/#Features-70","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Temporarily remove macos from travis due to stalled service\nFix documentation\nwork around TYPEDSIGNATURES bug\nadd typehierarchy to  doc\nAdd typehierarchy.md\nPatch version bump\nfirst version with working documentation on github","category":"page"},{"location":"changes/#[0.2.0]-2020-04-28","page":"Changes","title":"[0.2.0] - 2020-04-28","text":"","category":"section"},{"location":"changes/#Features-71","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Documentation overhaul\nVoronoiFVM examples now running after renaming to ExtendableGrids\nBase.show(grid) ceases to print arrays\nKeys -> Base.keys\nUpdated compat\nUpdated compat","category":"page"},{"location":"changes/#[0.1.0]-2020-04-25","page":"Changes","title":"[0.1.0] - 2020-04-25","text":"","category":"section"},{"location":"changes/#Features-72","page":"Changes","title":"Features","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Initialize with README\nAdded first files\nFixed README\nFirst tests are working...\nMore comments, introduce FixedTargetAdjacency\nFirst version of extendabele container idea\nContainers.md\nFixed pyplot for boundary grid\nFixed error in generation\nImproved formatting + comments\nModified ntargets etc. to num_targets etc.","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"added DocStringExtensions","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Fixed getindex for CellTypes\nFirst steps to interaction with VoronoiFVM\nWorking for 1D Examples in VoronoiFVM\nFixes for 2D VoronoiFVM\nSorted API\nVersion bump\nTypos\nMore stuff moved over from VoronoiFVM.Grid\nVersion bump\nStarted Documenter stuff\nFixed vectorofconstants: unique\nVersion 0.1.5\nRestarting as ExtendableGrids\nTypo\nReplaced all occurences of XGrid\nAdd travis, tagbot\nModified README, badges\nAdd Test in Project.toml\nAdd Printf in Project.toml\nFixed compat...","category":"page"},{"location":"subgrid/#Subgrid","page":"Subgrid","title":"Subgrid","text":"","category":"section"},{"location":"subgrid/","page":"Subgrid","title":"Subgrid","text":"Subgrids of an ExtendableGrid are again of the same type ExtendableGrid and unse the typed Dict mechanism to store linkage to the parent grid.","category":"page"},{"location":"subgrid/","page":"Subgrid","title":"Subgrid","text":"using ExtendableGrids # hide\ngrid=simplexgrid([1,2,3], [4,5,6])\nsub=subgrid(grid,[2],boundary=true, transform=(a,b) -> (a[1]=10*b[2]))\nprintln(keys(sub))\nprintln(sub[Coordinates])","category":"page"},{"location":"subgrid/","page":"Subgrid","title":"Subgrid","text":"Given a vector on the parent grid, one can create a view of this vecotor on the subgrid:","category":"page"},{"location":"subgrid/","page":"Subgrid","title":"Subgrid","text":"using ExtendableGrids # hide\ngrid=simplexgrid([1,2,3], [4,5,6])\nsub=subgrid(grid,[2],boundary=true, transform=(a,b) -> (a[1]=10*b[2]))\nv=[i for i=1:num_nodes(grid)]\nsubv=view(v,sub)\nprintln(subv)","category":"page"},{"location":"subgrid/#API","page":"Subgrid","title":"API","text":"","category":"section"},{"location":"subgrid/","page":"Subgrid","title":"Subgrid","text":"Modules = [ExtendableGrids]\nPages = [\"subgrid.jl\"]","category":"page"},{"location":"subgrid/#ExtendableGrids.BFaceParents","page":"Subgrid","title":"ExtendableGrids.BFaceParents","text":"abstract type BFaceParents <: AbstractGridIntegerArray1D\n\nGrid component key type for storing parent bfaces\n\n\n\n\n\n","category":"type"},{"location":"subgrid/#ExtendableGrids.CellParents","page":"Subgrid","title":"ExtendableGrids.CellParents","text":"abstract type CellParents <: AbstractGridIntegerArray1D\n\nGrid component key type for storing parent cells\n\n\n\n\n\n","category":"type"},{"location":"subgrid/#ExtendableGrids.FaceParents","page":"Subgrid","title":"ExtendableGrids.FaceParents","text":"abstract type FaceParents <: AbstractGridIntegerArray1D\n\nGrid component key type for storing parent faces (only for SubGrid relation when FaceNodes is instantiated)\n\n\n\n\n\n","category":"type"},{"location":"subgrid/#ExtendableGrids.NodeParents","page":"Subgrid","title":"ExtendableGrids.NodeParents","text":"abstract type NodeParents <: AbstractGridIntegerArray1D\n\nGrid component key type for storing node parents (=ids of nodes in ParentGrid) in an array\n\n\n\n\n\n","category":"type"},{"location":"subgrid/#ExtendableGrids.ParentGrid","page":"Subgrid","title":"ExtendableGrids.ParentGrid","text":"abstract type ParentGrid <: AbstractGridComponent\n\nGrid component key type for storing parent grid\n\n\n\n\n\n","category":"type"},{"location":"subgrid/#ExtendableGrids.ParentGridRelation","page":"Subgrid","title":"ExtendableGrids.ParentGridRelation","text":"abstract type ParentGridRelation <: AbstractGridComponent\n\nGrid component key type for storing parent grid relationship\n\n\n\n\n\n","category":"type"},{"location":"subgrid/#ExtendableGrids.RefinedGrid","page":"Subgrid","title":"ExtendableGrids.RefinedGrid","text":"abstract type RefinedGrid <: ParentGridRelation\n\nGrid component key type for indicating that grid is a refinement of the parentgrid\n\n\n\n\n\n","category":"type"},{"location":"subgrid/#ExtendableGrids.SubGrid","page":"Subgrid","title":"ExtendableGrids.SubGrid","text":"abstract type SubGrid{support} <: ParentGridRelation\n\nGrid component key type for indicating that grid is a subgrid of the parentgrid\n\n\n\n\n\n","category":"type"},{"location":"subgrid/#ExtendableGrids.SubgridVectorView","page":"Subgrid","title":"ExtendableGrids.SubgridVectorView","text":"struct SubgridVectorView{Tv, Ti} <: AbstractArray{Tv, 1}\n\nVector view on subgrid\n\nsysarray::AbstractVector\nnode_in_parent::Vector\n\n\n\n\n\n","category":"type"},{"location":"subgrid/#Base.getindex-Tuple{ExtendableGrids.SubgridVectorView, Integer}","page":"Subgrid","title":"Base.getindex","text":"getindex(\n    aview::ExtendableGrids.SubgridVectorView,\n    inode::Integer\n) -> Any\n\n\nAccessor method for subgrid vector view.\n\n\n\n\n\n","category":"method"},{"location":"subgrid/#Base.setindex!-Tuple{ExtendableGrids.SubgridVectorView, Any, Integer}","page":"Subgrid","title":"Base.setindex!","text":"setindex!(\n    aview::ExtendableGrids.SubgridVectorView,\n    v,\n    inode::Integer\n) -> ExtendableGrids.SubgridVectorView\n\n\nAccessor method for subgrid vector view.\n\n\n\n\n\n","category":"method"},{"location":"subgrid/#Base.size-Tuple{ExtendableGrids.SubgridVectorView}","page":"Subgrid","title":"Base.size","text":"size(a::ExtendableGrids.SubgridVectorView) -> Tuple{Int64}\n\n\nReturn size of vector view.\n\n\n\n\n\n","category":"method"},{"location":"subgrid/#Base.view-Tuple{AbstractVector, ExtendableGrid}","page":"Subgrid","title":"Base.view","text":"view(a::AbstractVector, subgrid::ExtendableGrid) -> Any\n\n\nCreate a view of the vector on a subgrid.\n\n\n\n\n\n","category":"method"},{"location":"subgrid/#ExtendableGrids._copytransform!-Tuple{AbstractArray, AbstractArray}","page":"Subgrid","title":"ExtendableGrids._copytransform!","text":"_copytransform!(a::AbstractArray, b::AbstractArray)\n\n\nDefault transform for subgrid creation\n\n\n\n\n\n","category":"method"},{"location":"subgrid/#ExtendableGrids.subgrid-Union{Tuple{T}, Tuple{Any, AbstractArray}} where T","page":"Subgrid","title":"ExtendableGrids.subgrid","text":"subgrid(parent,                                                             \n        subregions::AbstractArray;                                          \n        transform::T=function(a,b) @views a.=b[1:length(a)] end,                                      \n        boundary=false,                                                     \n        coordinatesystem=codim1_coordinatesystem(parent[CoordinateSystem]), \n        project=true) where T\n\nCreate subgrid from list of regions.\n\nparent: parent grid \nsubregions:  Array of subregions which define the subgrid\n'support': support of subgrid, default is ONCELLS but can be also ONFACES or ON_BFACES to create codimension 1 subgrid from face/bfaces region\nboundary: if true, create codimension 1 subgrid from boundary regions (same as support = ON_BFACES)\ntransform (kw parameter): transformation function between  grid and subgrid coordinates acting on one point.\ncoordinatesystem: if boundary==true, specify coordinate system for the boundary.  Default:  if parent coordinatesystem is cartesian, just the cooresponding codim1 coordinatesystem,   otherwise: nothing, requiring user specification for use of e.g. CellFinder with the subgrid.\nproject: project coordinates onto  subgrid dimension\n\nA subgrid is of type ExtendableGrid and stores two additional components: ParentGrid and NodeParents\n\n\n\n\n\n","category":"method"},{"location":"more/#Derived-adjacencies","page":"Derived adjacencies","title":"Derived adjacencies","text":"","category":"section"},{"location":"more/#API","page":"Derived adjacencies","title":"API","text":"","category":"section"},{"location":"more/","page":"Derived adjacencies","title":"Derived adjacencies","text":"Modules = [ExtendableGrids]\nPages = [\"derived.jl\",\"more.jl\"]","category":"page"},{"location":"more/#ExtendableGrids.BFaceCells","page":"Derived adjacencies","title":"ExtendableGrids.BFaceCells","text":"abstract type BFaceCells <: AbstractGridAdjacency\n\nAdjacency describing cells per boundary or interior face\n\n\n\n\n\n","category":"type"},{"location":"more/#ExtendableGrids.BFaceEdges","page":"Derived adjacencies","title":"ExtendableGrids.BFaceEdges","text":"abstract type BFaceEdges <: AbstractGridAdjacency\n\nAdjacency describing edges per boundary or interior face\n\n\n\n\n\n","category":"type"},{"location":"more/#ExtendableGrids.BFaceNormals","page":"Derived adjacencies","title":"ExtendableGrids.BFaceNormals","text":"abstract type BFaceNormals <: AbstractGridComponent\n\nAdjacency describing outer normals to boundary faces\n\n\n\n\n\n","category":"type"},{"location":"more/#ExtendableGrids.prepare_edges!-Tuple{ExtendableGrid}","page":"Derived adjacencies","title":"ExtendableGrids.prepare_edges!","text":"prepare_edges!(grid)\n\n\nPrepare edge adjacencies (celledges, edgecells, edgenodes)\n\nCurrently depends on ExtendableSparse, we may want to remove this adjacency.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"},{"location":"coordinatesystem/#Coordinate-systems","page":"Coordinate systems","title":"Coordinate systems","text":"","category":"section"},{"location":"coordinatesystem/","page":"Coordinate systems","title":"Coordinate systems","text":"Coordinate systems are described via abstract types. The list of coordinate systems can be obtained with the coordinatesystems method:","category":"page"},{"location":"coordinatesystem/","page":"Coordinate systems","title":"Coordinate systems","text":"using ExtendableGrids # hide\ncoordinatesystems() #hide","category":"page"},{"location":"coordinatesystem/#API","page":"Coordinate systems","title":"API","text":"","category":"section"},{"location":"coordinatesystem/","page":"Coordinate systems","title":"Coordinate systems","text":"Modules = [ExtendableGrids]\nPages = [\"coordinatesystem.jl\"]","category":"page"},{"location":"coordinatesystem/#ExtendableGrids.AbstractCoordinateSystem","page":"Coordinate systems","title":"ExtendableGrids.AbstractCoordinateSystem","text":"abstract type AbstractCoordinateSystem <: AbstractExtendableGridApexType\n\nApex type for coordinate systems\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Cartesian1D","page":"Coordinate systems","title":"ExtendableGrids.Cartesian1D","text":"abstract type Cartesian1D <: AbstractCoordinateSystem\n\n1D cartesion coordinate system (unknown x)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Cartesian2D","page":"Coordinate systems","title":"ExtendableGrids.Cartesian2D","text":"abstract type Cartesian2D <: AbstractCoordinateSystem\n\n2D cartesion coordinate system (unknowns x,y)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Cartesian3D","page":"Coordinate systems","title":"ExtendableGrids.Cartesian3D","text":"abstract type Cartesian3D <: AbstractCoordinateSystem\n\n2D cartesion coordinate system (unknowns x,y,z)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Cylindrical2D","page":"Coordinate systems","title":"ExtendableGrids.Cylindrical2D","text":"abstract type Cylindrical2D <: AbstractCoordinateSystem\n\n2D cylindrical coordinate system (unknowns r,z)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Cylindrical3D","page":"Coordinate systems","title":"ExtendableGrids.Cylindrical3D","text":"abstract type Cylindrical3D <: AbstractCoordinateSystem\n\n3D cylindrical coordinate system (unknowns r,ϕ,z)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Polar1D","page":"Coordinate systems","title":"ExtendableGrids.Polar1D","text":"abstract type Polar1D <: AbstractCoordinateSystem\n\n1D polar coordinate system (unknown r)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Polar2D","page":"Coordinate systems","title":"ExtendableGrids.Polar2D","text":"abstract type Polar2D <: AbstractCoordinateSystem\n\n2D polar coordinate system (unknowns r,ϕ)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Spherical1D","page":"Coordinate systems","title":"ExtendableGrids.Spherical1D","text":"abstract type Spherical1D <: AbstractCoordinateSystem\n\n1D spheriacal coordinate system (unknown r)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Spherical3D","page":"Coordinate systems","title":"ExtendableGrids.Spherical3D","text":"abstract type Spherical3D <: AbstractCoordinateSystem\n\n3D spheriacal coordinate system (unknowns r,ϕ,θ)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.codim1_coordinatesystem-Union{Tuple{Type{T}}, Tuple{T}} where T<:AbstractCoordinateSystem","page":"Coordinate systems","title":"ExtendableGrids.codim1_coordinatesystem","text":"codim1_coordinatesystem(CoordinateSystem)\n\nReturn coordinate system for codimension 1 subgrid.\n\n\n\n\n\n","category":"method"},{"location":"coordinatesystem/#ExtendableGrids.coordinatesystems-Tuple{}","page":"Coordinate systems","title":"ExtendableGrids.coordinatesystems","text":"coordinatesystems()\n\n\nList possible coordinate systems. These describe the meaning of the grid coordinates.\n\n\n\n\n\n","category":"method"}]
}
