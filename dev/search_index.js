var documenterSearchIndex = {"docs":
[{"location":"refinement/#Mesh-refinement","page":"Mesh refinement","title":"Mesh refinement","text":"","category":"section"},{"location":"refinement/#API","page":"Mesh refinement","title":"API","text":"","category":"section"},{"location":"refinement/","page":"Mesh refinement","title":"Mesh refinement","text":"Modules = [ExtendableGrids]\nPages = [\"meshrefinements.jl\",\"adaptive_meshrefinements.jl\"]","category":"page"},{"location":"refinement/#ExtendableGrids.RGB_refine-Union{Tuple{K}, Tuple{T}, Tuple{ExtendableGrid{T, K}, Vector{Bool}}} where {T, K}","page":"Mesh refinement","title":"ExtendableGrids.RGB_refine","text":"RGB_refine(\n    source_grid::ExtendableGrid{T, K},\n    facemarkers::Vector{Bool}\n) -> ExtendableGrid\n\n\ngenerates a new ExtendableGrid by red-green-blue mesh refinement of triangular meshes, see e.g.\n\nCarstensen, C. –An Adaptive Mesh-Refining Algorithm Allowing for an H^1 Stable L^2 Projection onto Courant Finite Element Spaces– Constr Approx 20, 549–564 (2004). https://doi.org/10.1007/s00365-003-0550-5\n\nThe bool array facemarkers determines which faces should be bisected. Note, that a closuring is performed such that the first face in every triangle with a marked face is also refined.\n\n\n\n\n\n","category":"method"},{"location":"refinement/#ExtendableGrids.barycentric_refine-Union{Tuple{ExtendableGrid{T, K}}, Tuple{K}, Tuple{T}} where {T, K}","page":"Mesh refinement","title":"ExtendableGrids.barycentric_refine","text":"barycentric_refine(\n    source_grid::ExtendableGrid{T, K}\n) -> ExtendableGrid\n\n\ngenerates a new ExtendableGrid by barycentric refinement of each cell in the source grid\n\nbarycentric refinement is available for these ElementGeometries\n\nQuadrilateral2D (first split into Triangle2D)\nTriangle2D\n\n\n\n\n\n","category":"method"},{"location":"refinement/#ExtendableGrids.split_grid_into-Union{Tuple{K}, Tuple{T}, Tuple{ExtendableGrid{T, K}, Type{<:AbstractElementGeometry}}} where {T, K}","page":"Mesh refinement","title":"ExtendableGrids.split_grid_into","text":"split_grid_into(\n    source_grid::ExtendableGrid{T, K},\n    targetgeometry::Type{<:AbstractElementGeometry}\n) -> ExtendableGrid\n\n\ngenerates a new ExtendableGrid by splitting each cell into subcells of the specified targetgeometry\n\nsplit rules exist for\n\nQuadrilateral2D into Triangle2D\nHexahedron3D into Tetrahedron3D\n\n\n\n\n\n","category":"method"},{"location":"refinement/#ExtendableGrids.uniform_refine-Union{Tuple{ExtendableGrid{T, K}}, Tuple{K}, Tuple{T}} where {T, K}","page":"Mesh refinement","title":"ExtendableGrids.uniform_refine","text":"uniform_refine(\n    source_grid::ExtendableGrid{T, K};\n    store_parents\n) -> ExtendableGrid\n\n\ngenerates a new ExtendableGrid by uniform refinement of each cell in the given grid\n\nuniform refinement rules are available for these AbstractElementGeometries:\n\nLine1D (bisection into two subsegments)\nTriangle2D (red refinement into four subtriangles)\nQuadrilateral2D (into four subquadrilaterals)\nTetrahedron (into eight subtetrahedrons)\nHexahedron (into eight subhexahedrons)\n\nif multiple geometries are in the mesh uniform refinement will only work if all refinement rules refine faces and edges (in 3D) equally (so no hanging nodes are created)\n\n\n\n\n\n","category":"method"},{"location":"examples/examples2d/#D-Grid-examples","page":"2D Grid examples","title":"2D Grid examples","text":"","category":"section"},{"location":"examples/examples2d/#Rectangle","page":"2D Grid examples","title":"Rectangle","text":"","category":"section"},{"location":"examples/examples2d/","page":"2D Grid examples","title":"2D Grid examples","text":"function rectangle()\n    X=collect(0:0.05:1)\n    Y=collect(0:0.05:1)\n    simplexgrid(X,X)\nend","category":"page"},{"location":"examples/examples2d/","page":"2D Grid examples","title":"2D Grid examples","text":"(Image: )","category":"page"},{"location":"examples/examples2d/#Rectangle-with-local-refinement","page":"2D Grid examples","title":"Rectangle with local refinement","text":"","category":"section"},{"location":"examples/examples2d/","page":"2D Grid examples","title":"2D Grid examples","text":"function rectangle_localref()\n    hmin=0.01\n    hmax=0.1\n    XLeft=geomspace(0.0,0.5,hmax,hmin)\n    XRight=geomspace(0.5,1.0,hmin,hmax)\n    X=glue(XLeft, XRight)\n    simplexgrid(X,X)\nend","category":"page"},{"location":"examples/examples2d/","page":"2D Grid examples","title":"2D Grid examples","text":"(Image: )","category":"page"},{"location":"examples/examples2d/#Rectangle-with-multiple-regions","page":"2D Grid examples","title":"Rectangle with multiple regions","text":"","category":"section"},{"location":"examples/examples2d/","page":"2D Grid examples","title":"2D Grid examples","text":"function rectangle_multiregion()\n    X=collect(0:0.05:1)\n    Y=collect(0:0.05:1)\n    grid=simplexgrid(X,Y)\n    cellmask!(grid,[0.0,0.0],[1.0,0.5],3)\n    bfacemask!(grid,[0.0,0.0],[0.0,0.5],5)\n    bfacemask!(grid,[1.0,0.0],[1.0,0.5],6)\n    bfacemask!(grid,[0.0,0.5],[1.0,0.5],7)\nend","category":"page"},{"location":"examples/examples2d/","page":"2D Grid examples","title":"2D Grid examples","text":"(Image: )","category":"page"},{"location":"examples/examples2d/#Subgrid-from-rectangle","page":"2D Grid examples","title":"Subgrid from rectangle","text":"","category":"section"},{"location":"examples/examples2d/","page":"2D Grid examples","title":"2D Grid examples","text":"function rectangle_subgrid()\n    X=collect(0:0.05:1)\n    Y=collect(0:0.05:1)\n    grid=simplexgrid(X,Y)\n    rect!(grid,[0.25,0.25],[0.75,0.75];region=2, bregion=5)\n    subgrid(grid,[1])\nend","category":"page"},{"location":"examples/examples2d/","page":"2D Grid examples","title":"2D Grid examples","text":"(Image: )","category":"page"},{"location":"examples/examples2d/#Rect2d-with-bregion-function","page":"2D Grid examples","title":"Rect2d with bregion function","text":"","category":"section"},{"location":"examples/examples2d/","page":"2D Grid examples","title":"2D Grid examples","text":"Here, we use function as bregion parameter - this allows to have no bfaces at the interface between the two rects.","category":"page"},{"location":"examples/examples2d/","page":"2D Grid examples","title":"2D Grid examples","text":"function rect2d_bregion_function()\n    X=collect(0:0.5:10)\n    Y=collect(0:0.5:10)\n    grid=simplexgrid(X,Y)\n    rect!(grid,[5,4],[9,6];region=2, bregions=[5,5,5,5])\n\n    rect!(grid,[4,2],[5,8];region=2, bregion= cur-> cur == 5  ? 0 : 8   )\n\n    subgrid(grid,[2])\n\nend","category":"page"},{"location":"examples/examples2d/","page":"2D Grid examples","title":"2D Grid examples","text":"(Image: )","category":"page"},{"location":"examples/examples2d/","page":"2D Grid examples","title":"2D Grid examples","text":"function sorted_subgrid(; maxvolume=0.01)\n\n    builder=SimplexGridBuilder(Generator=Triangulate)\n\n    p1=point!(builder,0,0)\n    p2=point!(builder,1,0)\n    p3=point!(builder,1,2)\n    p4=point!(builder,0,1)\n    p5=point!(builder,-1,2)\n\n    facetregion!(builder,1)\n    facet!(builder,p1,p2)\n    facetregion!(builder,2)\n    facet!(builder,p2,p3)\n    facetregion!(builder,3)\n    facet!(builder,p3,p4)\n    facetregion!(builder,4)\n    facet!(builder,p4,p5)\n    facetregion!(builder,5)\n    facet!(builder,p5,p1)\n\n    g=simplexgrid(builder;maxvolume)\n    sg=subgrid(g,[2],boundary=true,transform=(a,b)->a[1]=b[2])\n    f=map( (x,y)->sin(3x)*cos(3y),g)\n    sf=view(f,sg)\n    g,sg,sf\nend","category":"page"},{"location":"examples/examples2d/","page":"2D Grid examples","title":"2D Grid examples","text":"(Image: )","category":"page"},{"location":"examples/examples2d/","page":"2D Grid examples","title":"2D Grid examples","text":"","category":"page"},{"location":"examples/examples2d/","page":"2D Grid examples","title":"2D Grid examples","text":"This page was generated using Literate.jl.","category":"page"},{"location":"assembly/#Assembly-support","page":"Assembly support","title":"Assembly support","text":"","category":"section"},{"location":"assembly/#API","page":"Assembly support","title":"API","text":"","category":"section"},{"location":"assembly/","page":"Assembly support","title":"Assembly support","text":"Modules = [ExtendableGrids]\nPages = [\"assemblytypes.jl\",\"l2gtransformations.jl\"]","category":"page"},{"location":"assembly/#ExtendableGrids.AT_NODES","page":"Assembly support","title":"ExtendableGrids.AT_NODES","text":"abstract type AT_NODES <: AssemblyType\n\ncauses interpolation at vertices of the grid (only for H1-conforming interpolations)\n\n\n\n\n\n","category":"type"},{"location":"assembly/#ExtendableGrids.ON_BEDGES","page":"Assembly support","title":"ExtendableGrids.ON_BEDGES","text":"abstract type ON_BEDGES <: AssemblyType\n\ncauses assembly/interpolation on boundary edges of the grid (only in 3D)\n\n\n\n\n\n","category":"type"},{"location":"assembly/#ExtendableGrids.ON_BFACES","page":"Assembly support","title":"ExtendableGrids.ON_BFACES","text":"abstract type ON_BFACES <: AssemblyType\n\ncauses assembly/interpolation on boundary faces of the grid\n\n\n\n\n\n","category":"type"},{"location":"assembly/#ExtendableGrids.ON_CELLS","page":"Assembly support","title":"ExtendableGrids.ON_CELLS","text":"abstract type ON_CELLS <: AssemblyType\n\ncauses assembly/interpolation on cells of the grid\n\n\n\n\n\n","category":"type"},{"location":"assembly/#ExtendableGrids.ON_EDGES","page":"Assembly support","title":"ExtendableGrids.ON_EDGES","text":"abstract type ON_EDGES <: AssemblyType\n\ncauses assembly/interpolation on edges of the grid (only in 3D)\n\n\n\n\n\n","category":"type"},{"location":"assembly/#ExtendableGrids.ON_FACES","page":"Assembly support","title":"ExtendableGrids.ON_FACES","text":"abstract type ON_FACES <: AssemblyType\n\ncauses assembly/interpolation on faces of the grid\n\n\n\n\n\n","category":"type"},{"location":"assembly/#ExtendableGrids.ON_IFACES","page":"Assembly support","title":"ExtendableGrids.ON_IFACES","text":"abstract type ON_IFACES <: ON_FACES\n\ncauses assembly/interpolation on interior faces of the grid\n\n\n\n\n\n","category":"type"},{"location":"assembly/#ExtendableGrids.L2GTransformer","page":"Assembly support","title":"ExtendableGrids.L2GTransformer","text":"L2GTransformer\n\nTransforms reference coordinates to global coordinates\n\n\n\n\n\n","category":"type"},{"location":"voronoi/#Voronoi-tools","page":"Voronoi tools","title":"Voronoi tools","text":"","category":"section"},{"location":"voronoi/#API","page":"Voronoi tools","title":"API","text":"","category":"section"},{"location":"voronoi/","page":"Voronoi tools","title":"Voronoi tools","text":"Modules = [ExtendableGrids]\nPages = [\"voronoi.jl\"]","category":"page"},{"location":"voronoi/#ExtendableGrids.VoronoiFaceCenters","page":"Voronoi tools","title":"ExtendableGrids.VoronoiFaceCenters","text":"abstract type VoronoiFaceCenters <: AbstractGridFloatArray2D\n\nCenters of voronoi cell facets (currently 1D, 2D).\n\n\n\n\n\n","category":"type"},{"location":"voronoi/#ExtendableGrids.tricircumcenter!-NTuple{4, Any}","page":"Voronoi tools","title":"ExtendableGrids.tricircumcenter!","text":"tricircumcenter!(circumcenter, a, b, c)\n\n\nFind the circumcenter of a triangle.                 \n\nDerived from C source of Jonathan R Shewchuk <jrs@cs.cmu.edu>\n\nModified to return absolute coordinates.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"allindex/#Types-and-Constructors","page":"Index","title":"Types and Constructors","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"Modules = [ExtendableGrids]\nOrder=[:type]","category":"page"},{"location":"allindex/#Constants","page":"Index","title":"Constants","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"Modules = [ExtendableGrids]\nOrder=[:constant]","category":"page"},{"location":"allindex/#Methods","page":"Index","title":"Methods","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"Modules = [ExtendableGrids]\nOrder=[:function]","category":"page"},{"location":"gridconstructors/#Grid-constructors","page":"Grid constructors","title":"Grid constructors","text":"","category":"section"},{"location":"gridconstructors/#API","page":"Grid constructors","title":"API","text":"","category":"section"},{"location":"gridconstructors/","page":"Grid constructors","title":"Grid constructors","text":"Modules = [ExtendableGrids]\nPages = [\"simplexgrid.jl\",\"commongrids.jl\"]","category":"page"},{"location":"gridconstructors/#ExtendableGrids.glue-Tuple{Any, Any}","page":"Grid constructors","title":"ExtendableGrids.glue","text":"function glue(g1,g2;             g1regions=1:numbfaceregions(g1),             g2regions=1:numbfaceregions(g2),             interface=0,             tol=1.0e-10)\n\nMerge two grids along their common boundary facets. \n\ng1: First grid to be merged\ng2: Second grid to be merged\ng1regions: boundary regions to be used from grid1. Default: all.\ng2regions: boundary regions to be used from grid2. Default: all.\ninterface: if nonzero, create interface region in new grid, otherwise, ignore\ntol:  Distance below which two points are seen as identical. Default: 1.0e-10\n\nDeprecated:\n\nbreg: old notation for interface\n\n\n\n\n\n","category":"method"},{"location":"gridconstructors/#ExtendableGrids.simplexgrid-Tuple{AbstractVector, AbstractVector, AbstractVector}","page":"Grid constructors","title":"ExtendableGrids.simplexgrid","text":"simplexgrid(X,Y,Z; bregions=[1,2,3,4,5,6],cellregion=1)\n\nConstructor for 3D grid from coordinate arrays.  Boundary region numbers:\n\nlocation number\nsouth 1\neast 2\nnorth 3\nwest 4\nbottom 5\ntop 6\n\nThe keyword arguments allow to overwrite the default region numbers.\n\n\n\n\n\n","category":"method"},{"location":"gridconstructors/#ExtendableGrids.simplexgrid-Tuple{AbstractVector, AbstractVector}","page":"Grid constructors","title":"ExtendableGrids.simplexgrid","text":"simplexgrid(X,Y; bregions=[1,2,3,4],cellregion=1)\n\nConstructor for 2D grid from coordinate arrays. \n\nBoundary region numbers count counterclockwise:\n\nlocation number\nsouth 1\neast 2\nnorth 3\nwest 4\n\nThe keyword arguments allow to overwrite the default region numbers.\n\n\n\n\n\n","category":"method"},{"location":"gridconstructors/#ExtendableGrids.simplexgrid-Tuple{AbstractVector}","page":"Grid constructors","title":"ExtendableGrids.simplexgrid","text":"simplexgrid(X; bregions=[1,2],cellregion=1)\n\nConstructor for 1D grid.\n\nConstruct 1D grid from an array of node cordinates. It creates two boundary regions with index 1 at the left end and index 2 at the right end by default.\n\nThe keyword arguments allow to overwrite the default region numbers.\n\nPrimal grid holding unknowns: marked by o, dual grid marking control volumes: marked by |.\n\n o-----o-----o-----o-----o-----o-----o-----o-----o\n |--|-----|-----|-----|-----|-----|-----|-----|--|\n\n\n\n\n\n","category":"method"},{"location":"gridconstructors/#ExtendableGrids.simplexgrid-Tuple{ExtendableGrid, Any}","page":"Grid constructors","title":"ExtendableGrids.simplexgrid","text":"simplexgrid(grid2d::ExtendableGrid, coordZ; bot_offset=0,cell_offset=0,top_offset=0, bface_offset=0)\n\nCreate tensor product of 2D  grid and 1D coordinate array.\n\nCellregions and outer facet regions are taken over from 2D grid and added to cell_offset and bface_offset, respectively. Top an bottom facet regions are detected from the cell regions and added to bot_offset resp. top_offset.\n\n\n\n\n\n","category":"method"},{"location":"gridconstructors/#ExtendableGrids.simplexgrid-Union{Tuple{Ti}, Tuple{Tc}, Tuple{AbstractMatrix{Tc}, AbstractMatrix{Ti}, Any, Any, Any}} where {Tc, Ti}","page":"Grid constructors","title":"ExtendableGrids.simplexgrid","text":"function simplexgrid(coord::Array{Tc,2},\n                     cellnodes::Array{Ti,2},\n                     cellregions,\n                     bfacenodes,\n                     bfaceregions\n                     ) where {Tc,Ti}\n\nCreate  d-dimensional simplex grid from five arrays.\n\ncoord: d times n_points matrix of coordinates\ncellnodes: d+1 times n_tri matrix of triangle - point incidence\ncellregions: n_tri vector of cell region markers\nbfacenodes: d times n_bf matrix of boundary facet - point incidences\nbfaceregions: n_bf vector of boundary facet  region markers\n\nCoordinate type Tc index type Ti are detected from the first two parameters. cellregions, bfaceregions, bfacenodes are converted to have the same element type as cellnodes.\n\n\n\n\n\n","category":"method"},{"location":"gridconstructors/#ExtendableGrids.simplexgrid-Union{Tuple{Ti}, Tuple{Tc}, Tuple{Matrix{Tc}, Matrix{Ti}, Vararg{Any, 5}}} where {Tc, Ti}","page":"Grid constructors","title":"ExtendableGrids.simplexgrid","text":"function simplexgrid(coord::Array{Tc,2},\n                     cellnodes::Array{Ti,2},\n                     cellregions,\n                     bfacenodes,\n                     bfaceregions,\n                     bedgenodes,\n                     bedgeregions\n                     ) where {Tc,Ti}\n\nCreate simplex grid from coordinates, cell-nodes-adjancency, cell-region-numbers, boundary-face-nodes adjacency, boundary-face-region-numbers, boundary-edge-nodes, and boundary-edge-region-numbers arrays.\n\nThe index type Ti is detected from cellnodes, all other arrays besides coord are converted to this index type.\n\n\n\n\n\n","category":"method"},{"location":"gridconstructors/#ExtendableGrids.grid_triangle-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Grid constructors","title":"ExtendableGrids.grid_triangle","text":"    Triangle(coords) -> ExtendableGrid{T,Int32}\n\nGenerates a single triangle with the given coordinates, that should be a 2 x 3 array with the coordinates of the three vertices, e.g. coords = [0.0 0.0; 1.0 0.0; 0.0 1.0]'.\n\n\n\n\n\n","category":"method"},{"location":"gridconstructors/#ExtendableGrids.reference_domain","page":"Grid constructors","title":"ExtendableGrids.reference_domain","text":"    reference_domain(EG::Type{<:AbstractElementGeometry}, T::Type{<:Real} = Float64; scale = [1,1,1], shift = [0,0,0]) -> ExtendableGrid{T,Int32}\n\nGenerates an ExtendableGrid{T,Int32} for the reference domain of the specified Element Geometry. With scale and shift the coordinates can be manipulated.\n\n\n\n\n\n","category":"function"},{"location":"adjacency/#Adjacency","page":"Adjacency","title":"Adjacency","text":"","category":"section"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"This handles adjacency matrices between entities of polyhedral complexes, e.g. nodes, cells, edges etc.","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"An adjacency is described by an Adjacency matrix, which is a sparse matrix whose entries a 0 or 1. While such a matrix always can be stored as a SparseMatrixCSC, in general this would be a waste of storage.","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"For the general case, it is sufficient to only store the column start indieces and the column entries (row numbers), and to implicitely assume that nonzero entries are 1. This kind of storage is realised in a VariableTargetAdjacency.","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"In many cases, this can be compressed even more, if each column has the same length. In that case, a Matrix is sufficient to store the data. This is the usual base for implementing FEM/FVM assembly, and the interface for the general case should be similar.","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"From these ideas we develop the following interface for an adjacency a.","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"In order to avoid name confusion, we introduce the following notation which  should be consistent with the use in assembly loops.","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"source:  source of adjacency link target:  target of adjacency link","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"E.g. the cell-node adjacency for FEM assembly links  a number of cells with a collection of nodes.  The cells are the sources, and the targets are the nodes. ","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"getindex(a,i,isource) aka a[i,isource]: return i-th target of  source j    numsources(a): overall number of sources, e.g. number of cells    numtargets(a): overall number of targets    numtargets(a,isource): number of targets for source given by isource    numlinks(a): number of links aka nonzero entries of adjacency matrix    show(a): print stuff","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"Further API ideas:","category":"page"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"Convert between Matrix and Variable target stuff using 0 entries as \"padding\"","category":"page"},{"location":"adjacency/#API","page":"Adjacency","title":"API","text":"","category":"section"},{"location":"adjacency/","page":"Adjacency","title":"Adjacency","text":"Modules = [ExtendableGrids]\nPages = [\"adjacency.jl\",\"serialadjacency.jl\"]","category":"page"},{"location":"adjacency/#ExtendableGrids.Adjacency","page":"Adjacency","title":"ExtendableGrids.Adjacency","text":"Adjacency type as union of FixedTargetAdjacency and VariableTargetAdjacency\n\n\n\n\n\n","category":"type"},{"location":"adjacency/#ExtendableGrids.Adjacency-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"Adjacency","title":"ExtendableGrids.Adjacency","text":"Constructors for Adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.FixedTargetAdjacency","page":"Adjacency","title":"ExtendableGrids.FixedTargetAdjacency","text":"mutable struct Array{T, 2} <: DenseArray{T, 2}\n\nUse Matrix to store fixed target adjacency\n\n\n\n\n\n","category":"type"},{"location":"adjacency/#ExtendableGrids.SerialVariableTargetAdjacency-Tuple{}","page":"Adjacency","title":"ExtendableGrids.SerialVariableTargetAdjacency","text":"SerialVariableTargetAdjacency(\n\n) -> SerialVariableTargetAdjacency{Int64}\n\n\nCreate an empty SerialVariableTargetAdjacency with default type\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.SerialVariableTargetAdjacency-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Adjacency","title":"ExtendableGrids.SerialVariableTargetAdjacency","text":"SerialVariableTargetAdjacency(\n    t::Type{T}\n) -> SerialVariableTargetAdjacency\n\n\nCreate an empty SerialVariableTargetAdjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.VariableTargetAdjacency","page":"Adjacency","title":"ExtendableGrids.VariableTargetAdjacency","text":"struct VariableTargetAdjacency{T}\n\nAdjacency struct. Essentially, this is the sparsity pattern of a matrix whose nonzero elements all have the same value in the CSC format.\n\n\n\n\n\n","category":"type"},{"location":"adjacency/#ExtendableGrids.VariableTargetAdjacency-Tuple{}","page":"Adjacency","title":"ExtendableGrids.VariableTargetAdjacency","text":"VariableTargetAdjacency() -> VariableTargetAdjacency{Int64}\n\n\nCreate an empty VariableTargetAdjacency with default type\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.VariableTargetAdjacency-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"Adjacency","title":"ExtendableGrids.VariableTargetAdjacency","text":"VariableTargetAdjacency(\n    m::Array{T, 2}\n) -> VariableTargetAdjacency\n\n\nCreate a VariableTargetAdjacency from Matrix\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.VariableTargetAdjacency-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv<:Integer, Ti<:Integer}","page":"Adjacency","title":"ExtendableGrids.VariableTargetAdjacency","text":"VariableTargetAdjacency(\n    m::SparseArrays.SparseMatrixCSC{Tv<:Integer, Ti<:Integer}\n) -> VariableTargetAdjacency\n\n\nCreate variable target adjacency from adjacency matrix\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.VariableTargetAdjacency-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Adjacency","title":"ExtendableGrids.VariableTargetAdjacency","text":"VariableTargetAdjacency(\n    t::Type{T}\n) -> VariableTargetAdjacency\n\n\nCreate an empty VariableTargetAdjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.:==-Union{Tuple{Tb}, Tuple{Ta}, Tuple{SerialVariableTargetAdjacency{Ta}, SerialVariableTargetAdjacency{Tb}}} where {Ta, Tb}","page":"Adjacency","title":"Base.:==","text":"==(a, b)\n\n\nComparison of two adjacencies\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.:==-Union{Tuple{Tb}, Tuple{Ta}, Tuple{VariableTargetAdjacency{Ta}, VariableTargetAdjacency{Tb}}} where {Ta, Tb}","page":"Adjacency","title":"Base.:==","text":"==(a, b)\n\n\nComparison of two adjacencies\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.append!-Tuple{SerialVariableTargetAdjacency, Any}","page":"Adjacency","title":"Base.append!","text":"append!(adj::SerialVariableTargetAdjacency, len) -> Vector\n\n\nAppend a column to adjacency.\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.append!-Tuple{VariableTargetAdjacency, Any}","page":"Adjacency","title":"Base.append!","text":"append!(adj::VariableTargetAdjacency, column) -> Vector\n\n\nAppend a column to adjacency.\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.getindex-Tuple{SerialVariableTargetAdjacency, Any, Any}","page":"Adjacency","title":"Base.getindex","text":"getindex(\n    adj::SerialVariableTargetAdjacency,\n    i,\n    isource\n) -> Any\n\n\nAccess adjacency as if it is a 2D Array\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.getindex-Tuple{VariableTargetAdjacency, Any, Any}","page":"Adjacency","title":"Base.getindex","text":"getindex(adj::VariableTargetAdjacency, i, isource) -> Any\n\n\nAccess adjacency as if it is a 2D Array\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.show-Tuple{IO, SerialVariableTargetAdjacency}","page":"Adjacency","title":"Base.show","text":"show(io::IO, adj::SerialVariableTargetAdjacency)\n\n\nShow adjacency (in trasposed form; preliminary)\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#Base.show-Tuple{IO, VariableTargetAdjacency}","page":"Adjacency","title":"Base.show","text":"show(io::IO, adj::VariableTargetAdjacency)\n\n\nShow adjacency (in trasposed form; preliminary)\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.asparse-Tuple{Matrix}","page":"Adjacency","title":"ExtendableGrids.asparse","text":"asparse(a::Matrix) -> SparseArrays.SparseMatrixCSC{Int64}\n\n\nCreate sparse incidence matrix from adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.asparse-Tuple{VariableTargetAdjacency}","page":"Adjacency","title":"ExtendableGrids.asparse","text":"asparse(\n    a::VariableTargetAdjacency\n) -> SparseArrays.SparseMatrixCSC{Int64}\n\n\nCreate sparse incidence matrix from adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.atranspose-Union{Tuple{Adjacency{T}}, Tuple{T}} where T","page":"Adjacency","title":"ExtendableGrids.atranspose","text":"Transpose adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.makevar-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"Adjacency","title":"ExtendableGrids.makevar","text":"makevar(a::Array{T, 2}) -> VariableTargetAdjacency\n\n\nTurn fixed target adjacency into variable target adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.max_num_targets_per_source-Tuple{Matrix}","page":"Adjacency","title":"ExtendableGrids.max_num_targets_per_source","text":"max_num_targets_per_source(adj::Matrix) -> Int64\n\n\nMaximum number of targets per source\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.max_num_targets_per_source-Tuple{SerialVariableTargetAdjacency}","page":"Adjacency","title":"ExtendableGrids.max_num_targets_per_source","text":"max_num_targets_per_source(\n    adj::SerialVariableTargetAdjacency\n) -> Any\n\n\nMaximum number of targets per source\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.max_num_targets_per_source-Tuple{VariableTargetAdjacency}","page":"Adjacency","title":"ExtendableGrids.max_num_targets_per_source","text":"max_num_targets_per_source(\n    adj::VariableTargetAdjacency\n) -> Any\n\n\nMaximum number of targets per source\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_links-Tuple{Matrix}","page":"Adjacency","title":"ExtendableGrids.num_links","text":"num_links(adj::Matrix) -> Int64\n\n\nNumber of entries\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_links-Tuple{VariableTargetAdjacency}","page":"Adjacency","title":"ExtendableGrids.num_links","text":"num_links(adj::VariableTargetAdjacency) -> Int64\n\n\nNumber of links\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_sources-Tuple{Matrix}","page":"Adjacency","title":"ExtendableGrids.num_sources","text":"num_sources(adj::Matrix) -> Int64\n\n\nNumber of sources in adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_sources-Tuple{SerialVariableTargetAdjacency}","page":"Adjacency","title":"ExtendableGrids.num_sources","text":"num_sources(adj::SerialVariableTargetAdjacency) -> Int64\n\n\nNumber of sources in adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_sources-Tuple{VariableTargetAdjacency}","page":"Adjacency","title":"ExtendableGrids.num_sources","text":"num_sources(adj::VariableTargetAdjacency) -> Int64\n\n\nNumber of sources in adjacency\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_targets-Tuple{Matrix, Any}","page":"Adjacency","title":"ExtendableGrids.num_targets","text":"num_targets(adj::Matrix, isource) -> Int64\n\n\nNumber of targets per source if adjacency is a matrix\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_targets-Tuple{Matrix}","page":"Adjacency","title":"ExtendableGrids.num_targets","text":"num_targets(adj::Matrix) -> Any\n\n\nOverall number of targets \n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_targets-Tuple{SerialVariableTargetAdjacency, Any}","page":"Adjacency","title":"ExtendableGrids.num_targets","text":"num_targets(\n    adj::SerialVariableTargetAdjacency,\n    isource\n) -> Any\n\n\nNumber of targets for given source\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_targets-Tuple{VariableTargetAdjacency, Any}","page":"Adjacency","title":"ExtendableGrids.num_targets","text":"num_targets(adj::VariableTargetAdjacency, isource) -> Any\n\n\nNumber of targets for given source\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.num_targets-Tuple{VariableTargetAdjacency}","page":"Adjacency","title":"ExtendableGrids.num_targets","text":"num_targets(adj::VariableTargetAdjacency) -> Any\n\n\nNumber of targeta\n\n\n\n\n\n","category":"method"},{"location":"adjacency/#ExtendableGrids.tryfix-Union{Tuple{Adjacency{T}}, Tuple{T}} where T","page":"Adjacency","title":"ExtendableGrids.tryfix","text":"tryfix(\n    a::Union{Array{T, 2}, VariableTargetAdjacency{T}}\n) -> Any\n\n\nTry to turn variable target adjacency into fixed target adjacency\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#Shape-specifications","page":"Shape specifications","title":"Shape specifications","text":"","category":"section"},{"location":"shape_specs/#API","page":"Shape specifications","title":"API","text":"","category":"section"},{"location":"shape_specs/","page":"Shape specifications","title":"Shape specifications","text":"Modules = [ExtendableGrids]\nPages = [\"shape_specs.jl\"]","category":"page"},{"location":"shape_specs/#ExtendableGrids.facetype_of_cellface-Tuple{Type{<:AbstractElementGeometry1D}, Any}","page":"Shape specifications","title":"ExtendableGrids.facetype_of_cellface","text":"facetype_of_cellface(_, k)\n\n\nGeometries of faces of 1D edge\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.facetype_of_cellface-Tuple{Type{<:Hexahedron3D}, Any}","page":"Shape specifications","title":"ExtendableGrids.facetype_of_cellface","text":"facetype_of_cellface(_, k)\n\n\nGeometries of faces of 3D hexahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.facetype_of_cellface-Tuple{Type{<:Parallelepiped3D}, Any}","page":"Shape specifications","title":"ExtendableGrids.facetype_of_cellface","text":"facetype_of_cellface(_, k)\n\n\nGeometries of faces of 3D parallelepiped\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.facetype_of_cellface-Tuple{Type{<:Quadrilateral2D}, Any}","page":"Shape specifications","title":"ExtendableGrids.facetype_of_cellface","text":"facetype_of_cellface(_, k)\n\n\nGeometries of faces of 2D quadrilateral\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.facetype_of_cellface-Tuple{Type{<:Tetrahedron3D}, Any}","page":"Shape specifications","title":"ExtendableGrids.facetype_of_cellface","text":"facetype_of_cellface(_, k)\n\n\nGeometries of faces of 3D tetrahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.facetype_of_cellface-Tuple{Type{<:Triangle2D}, Any}","page":"Shape specifications","title":"ExtendableGrids.facetype_of_cellface","text":"facetype_of_cellface(_, k)\n\n\nGeometries of faces of 2D triangle\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_celledgenodes-Tuple{Type{<:AbstractElementGeometry1D}}","page":"Shape specifications","title":"ExtendableGrids.local_celledgenodes","text":"local_celledgenodes(_)\n\n\nCell-edge node numbering for 1D edge\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_celledgenodes-Tuple{Type{<:Hexahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.local_celledgenodes","text":"local_celledgenodes(_)\n\n\nCell-edge node numbering for 3D hexahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_celledgenodes-Tuple{Type{<:Quadrilateral2D}}","page":"Shape specifications","title":"ExtendableGrids.local_celledgenodes","text":"local_celledgenodes(_)\n\n\nCell-edge node numbering for 2D quadrilateral\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_celledgenodes-Tuple{Type{<:Tetrahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.local_celledgenodes","text":"local_celledgenodes(_)\n\n\nCell-edge node numbering for 3D tetrahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_celledgenodes-Tuple{Type{<:Triangle2D}}","page":"Shape specifications","title":"ExtendableGrids.local_celledgenodes","text":"local_celledgenodes(_)\n\n\nCell-edge node numbering for 2D triangle\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_celledgenodes-Tuple{Type{Vertex0D}}","page":"Shape specifications","title":"ExtendableGrids.local_celledgenodes","text":"local_celledgenodes(_)\n\n\nCell-edge node numbering for 1D edge\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_cellfacenodes-Tuple{Type{<:AbstractElementGeometry1D}}","page":"Shape specifications","title":"ExtendableGrids.local_cellfacenodes","text":"local_cellfacenodes(_)\n\n\nCell-face node numbering for 1D edge\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_cellfacenodes-Tuple{Type{<:Hexahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.local_cellfacenodes","text":"local_cellfacenodes(_)\n\n\nCell-face node numbering for 3D hexahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_cellfacenodes-Tuple{Type{<:Quadrilateral2D}}","page":"Shape specifications","title":"ExtendableGrids.local_cellfacenodes","text":"local_cellfacenodes(_)\n\n\nCell-face node numbering for 2D quadrilateral\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_cellfacenodes-Tuple{Type{<:Tetrahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.local_cellfacenodes","text":"local_cellfacenodes(_)\n\n\nCell-face node numbering for 3D tetrahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.local_cellfacenodes-Tuple{Type{<:Triangle2D}}","page":"Shape specifications","title":"ExtendableGrids.local_cellfacenodes","text":"local_cellfacenodes(_)\n\n\nCell-face node numbering for 2D triangle\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_edges-Tuple{ExtendableGrid}","page":"Shape specifications","title":"ExtendableGrids.num_edges","text":"num_edges(grid)\n\n\nNumber of edges in grid.\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_edges-Tuple{Type{<:AbstractElementGeometry0D}}","page":"Shape specifications","title":"ExtendableGrids.num_edges","text":"num_edges(_)\n\n\nNumber of edges of 0D vertex\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_edges-Tuple{Type{<:AbstractElementGeometry1D}}","page":"Shape specifications","title":"ExtendableGrids.num_edges","text":"num_edges(_)\n\n\nNumber of edges for 1D edge\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_edges-Tuple{Type{<:Quadrilateral2D}}","page":"Shape specifications","title":"ExtendableGrids.num_edges","text":"num_edges(_)\n\n\nNumber of edges in 2D quadrilateral\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_edges-Tuple{Type{<:Tetrahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.num_edges","text":"num_edges(_)\n\n\nNumber of edges in 3D tetrahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_edges-Tuple{Type{<:Triangle2D}}","page":"Shape specifications","title":"ExtendableGrids.num_edges","text":"num_edges(_)\n\n\nNumber of edges in 2D triangle\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_edges-Tuple{Type{Edge1D}}","page":"Shape specifications","title":"ExtendableGrids.num_edges","text":"num_edges(_)\n\n\nNumber of edges of 1D edge\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_faces-Tuple{Type{<:AbstractElementGeometry0D}}","page":"Shape specifications","title":"ExtendableGrids.num_faces","text":"num_faces(_)\n\n\nNumber of faces of 0D vertex\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_faces-Tuple{Type{<:AbstractElementGeometry1D}}","page":"Shape specifications","title":"ExtendableGrids.num_faces","text":"num_faces(_)\n\n\nNumber of faces for 1D edge\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_faces-Tuple{Type{<:Quadrilateral2D}}","page":"Shape specifications","title":"ExtendableGrids.num_faces","text":"num_faces(_)\n\n\nNumber of faces in 2D quadrilateral\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_faces-Tuple{Type{<:Tetrahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.num_faces","text":"num_faces(_)\n\n\nNumber of faces in 3D tetrahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_faces-Tuple{Type{<:Triangle2D}}","page":"Shape specifications","title":"ExtendableGrids.num_faces","text":"num_faces(_)\n\n\nNumber of faces in 2D triangle\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_nodes-Tuple{Type{<:AbstractElementGeometry0D}}","page":"Shape specifications","title":"ExtendableGrids.num_nodes","text":"num_nodes(_)\n\n\nNumber of nodes of 0D vertex\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_nodes-Tuple{Type{<:AbstractElementGeometry1D}}","page":"Shape specifications","title":"ExtendableGrids.num_nodes","text":"num_nodes(_)\n\n\nNumber of nodes for 1D edge\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_nodes-Tuple{Type{<:Hexahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.num_nodes","text":"num_nodes(_)\n\n\nNumber of nodes in 3D hexahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_nodes-Tuple{Type{<:Quadrilateral2D}}","page":"Shape specifications","title":"ExtendableGrids.num_nodes","text":"num_nodes(_)\n\n\nNumber of nodes in 2D quadrilateral\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_nodes-Tuple{Type{<:Tetrahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.num_nodes","text":"num_nodes(_)\n\n\nNumber of nodes in 3D tetrahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.num_nodes-Tuple{Type{<:Triangle2D}}","page":"Shape specifications","title":"ExtendableGrids.num_nodes","text":"num_nodes(_)\n\n\nNumber of nodes in 2D triangle\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.refcoords_for_geometry-Tuple{Type{<:AbstractElementGeometry0D}}","page":"Shape specifications","title":"ExtendableGrids.refcoords_for_geometry","text":"refcoords_for_geometry(_)\n\n\nCoordinates of reference geometry of 0D vertex\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.refcoords_for_geometry-Tuple{Type{<:AbstractElementGeometry1D}}","page":"Shape specifications","title":"ExtendableGrids.refcoords_for_geometry","text":"refcoords_for_geometry(_)\n\n\nCoordinates of reference geometry of 1D edge\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.refcoords_for_geometry-Tuple{Type{<:Hexahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.refcoords_for_geometry","text":"refcoords_for_geometry(_)\n\n\nCoordinates of reference geometry of 3D hexahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.refcoords_for_geometry-Tuple{Type{<:Quadrilateral2D}}","page":"Shape specifications","title":"ExtendableGrids.refcoords_for_geometry","text":"refcoords_for_geometry(_)\n\n\nCoordinates of reference geometry of 2D quadrilateral\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.refcoords_for_geometry-Tuple{Type{<:Tetrahedron3D}}","page":"Shape specifications","title":"ExtendableGrids.refcoords_for_geometry","text":"refcoords_for_geometry(_)\n\n\nCoordinates of reference geometry of 3D tetrahedron\n\n\n\n\n\n","category":"method"},{"location":"shape_specs/#ExtendableGrids.refcoords_for_geometry-Tuple{Type{<:Triangle2D}}","page":"Shape specifications","title":"ExtendableGrids.refcoords_for_geometry","text":"refcoords_for_geometry(_)\n\n\nCoordinates of reference geometry of 2D triangle\n\n\n\n\n\n","category":"method"},{"location":"tdict/#The-TDict-interface-pattern","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Here we describe the idea behind the data structure used in this package. TDict means: extendable containers with type stable content access and lazy content creation via the Julia type system.","category":"page"},{"location":"tdict/#Problem-to-be-addressed","page":"The TDict interface pattern","title":"Problem to be addressed","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"In certain contexts it is desirable to use containers with core components which are user extendable and allow for type stable component acces. Moreover, some components are necessary on demand only, so they should be created lazily. Furthermore, there should be a kind of safety protocol which prevents errors from typos in component names etc.","category":"page"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Julia default data structures do not provide these properties.","category":"page"},{"location":"tdict/#struct","page":"The TDict interface pattern","title":"struct","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Julia structs with proper field type annotations guarantee type stability\nJulia structs are not extendable, fields and their types are fixed upon definition\nIf we don't fix types of struct fields they become Any and a source  for type instability\nThe situation could be fixed if getfield could be overloaded but it cant't","category":"page"},{"location":"tdict/#Dict","page":"The TDict interface pattern","title":"Dict","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Plain Dicts with flexible value types are a source of type instability\nDicts with strings as keys needs a meta protocol to handle semantics of keys which at the end probably hinges on string comparison which will make things slow\nDicts with symbols as keys still need this meta protocol\nSame for the implementation of a lazy evaluation protocol\nIf a dict contains components of different types, component access will not be typestable","category":"page"},{"location":"tdict/#Proposed-solution:","page":"The TDict interface pattern","title":"Proposed solution:","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Harness the power of the Julia type system: ","category":"page"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Use a struct containing a  Dict with DataType as keys. Every key is a type.\nUse type hierarchies to manage different  value classes\nUse the type system to dispatch between  getindex/setindex! methods for keys\nExtension requires declaring new types, keys can be only existing types almost removing typos as sources for errors\nLazy extension is managed bye an  instantiate method called by getindex if necessary\nComponent access is made type stable by type dispatchedgetindex methods\nComponent insertion is made safe by having  setindex!  calling a veryform method","category":"page"},{"location":"tdict/#Pros","page":"The TDict interface pattern","title":"Pros","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"See above ...","category":"page"},{"location":"tdict/#Cons","page":"The TDict interface pattern","title":"Cons","text":"","category":"section"},{"location":"tdict/","page":"The TDict interface pattern","title":"The TDict interface pattern","text":"Implemented using a Dict, so access is inherently slower than access to a component of a struct. Therefore it is not well suited for inner loops.","category":"page"},{"location":"extendablegrid/#Extendable-grid","page":"Extendable grid","title":"Extendable grid","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"An ExtendableGrid in form of a dictionary with types as keys and type stable value access. This means that grid components are accessed as dict entries, e.g. grid[Coordinates] . The rationale of this approach is explained here.","category":"page"},{"location":"extendablegrid/#Notations","page":"Extendable grid","title":"Notations","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"A grid is assumed to be a subset of components of a polyhedral complex in d-dimensional space. We distinguish the following element classes characterized by their dimension:","category":"page"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Element class Meaning\nNode 0-dimensional node\nEdge 1-dimensional line connecting two neigboring nodes\nFace codimension 1 object separating a cell from outer space or neigboring cell\nCell codimension 0 object\nBFace Face situated at inner or domain boundary\nRegion number to be used to characterize subdomains, contacts etc.","category":"page"},{"location":"extendablegrid/#Grid-components","page":"Extendable grid","title":"Grid components","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Grid components are accessed like Dict entries, the keys must be subtypes of AbstractGridComponent.","category":"page"},{"location":"extendablegrid/#Basic-set-of-grid-components","page":"Extendable grid","title":"Basic set of grid components","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Upon construction, an ExtendableGrid needs to be provided with the basic set of grid components denoted by the following component type keys:","category":"page"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Component type key Meaning\nCoordinates Coordinates of the vertices of the grid cells\nCellNodes Adjacency describing the nodes of grid cell\nCellGeometries Abstract array of subtypes of AbstractElementGeometry describing the geometry of each cell\nCellRegions Abstract array of integers describing region numbers\nBFaceNodes Adjacency structure describing the nodes corresponding to each grid boundary face\nBFaceGeometries Abstract array of subtypes of AbstractElementGeometry describing the geometry of each boundary face\nBFaceRegions Abstract array of integers describig region numbers\nCoordinateSystem Abstract type describing the coordinate system to be used","category":"page"},{"location":"extendablegrid/#Hierarchy-of-component-type-keys","page":"Extendable grid","title":"Hierarchy of component type keys","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"The list of components can be printed using the gridcomponents method.","category":"page"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"using ExtendableGrids # hide\ngridcomponents() #hide","category":"page"},{"location":"extendablegrid/#Additional-components","page":"Extendable grid","title":"Additional components","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Additional components can be added by defining  a subtype of AbstractGridComponent or a fitting subtype thereof, and assigning the value to the corresponding Dict entry:","category":"page"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"using ExtendableGrids # hide\ng=simplexgrid([1,2,3,4.0])\nabstract type MyComponent <: AbstractGridComponent end\ng[MyComponent]=13\nshow(g)","category":"page"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Alternatively, component creation can be perfomed lazily. For this purpose one needs to define an instantiate method:","category":"page"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"using ExtendableGrids # hide\nabstract type NodeCells <: AbstractGridAdjacency end\nExtendableGrids.instantiate(grid, ::Type{NodeCells})=atranspose(grid[CellNodes])\ng=simplexgrid([1,2,3,4.0])\nshow(g[NodeCells])","category":"page"},{"location":"extendablegrid/#Grid-API","page":"Extendable grid","title":"Grid API","text":"","category":"section"},{"location":"extendablegrid/","page":"Extendable grid","title":"Extendable grid","text":"Modules = [ExtendableGrids]\nPages = [\"extendablegrid.jl\"]","category":"page"},{"location":"extendablegrid/#ExtendableGrids.ElementInfo","page":"Extendable grid","title":"ExtendableGrids.ElementInfo","text":"const ElementInfo{T}=Union{Vector{T},VectorOfConstants{T}}\n\nUnion type for element information arrays. If all elements have the same information, it can be stored in an economical form as a VectorOfConstants.\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractElementGeometries","page":"Extendable grid","title":"ExtendableGrids.AbstractElementGeometries","text":"abstract type AbstractElementGeometries <: AbstractGridComponent\n\nArray of element geometry information. \n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractElementRegions","page":"Extendable grid","title":"ExtendableGrids.AbstractElementRegions","text":"abstract type AbstractElementRegions <: AbstractGridComponent\n\nArray of element region number information. \n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridAdjacency","page":"Extendable grid","title":"ExtendableGrids.AbstractGridAdjacency","text":"abstract type AbstractGridAdjacency <: AbstractGridComponent\n\nAny kind of adjacency between grid components\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridComponent","page":"Extendable grid","title":"ExtendableGrids.AbstractGridComponent","text":"abstract type AbstractGridComponent <: AbstractExtendableGridApexType\n\nApex type for grid components.\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridFloatArray1D","page":"Extendable grid","title":"ExtendableGrids.AbstractGridFloatArray1D","text":"abstract type AbstractGridFloatArray1D <: AbstractGridComponent\n\n1D Array of floating point data\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridFloatArray2D","page":"Extendable grid","title":"ExtendableGrids.AbstractGridFloatArray2D","text":"abstract type AbstractGridFloatArray2D <: AbstractGridComponent\n\n2D Array of floating point data\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridFloatConstant","page":"Extendable grid","title":"ExtendableGrids.AbstractGridFloatConstant","text":"abstract type AbstractGridFloatConstant <: AbstractGridComponent\n\nFloating point number\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridIntegerArray1D","page":"Extendable grid","title":"ExtendableGrids.AbstractGridIntegerArray1D","text":"abstract type AbstractGridIntegerArray1D <: AbstractGridComponent\n\n1D Array of interger data\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridIntegerArray2D","page":"Extendable grid","title":"ExtendableGrids.AbstractGridIntegerArray2D","text":"abstract type AbstractGridIntegerArray2D <: AbstractGridComponent\n\n2D Array of integer data\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.AbstractGridIntegerConstant","page":"Extendable grid","title":"ExtendableGrids.AbstractGridIntegerConstant","text":"abstract type AbstractGridIntegerConstant <: AbstractGridComponent\n\nInteger number\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.BEdgeRegions","page":"Extendable grid","title":"ExtendableGrids.BEdgeRegions","text":"abstract type BEdgeRegions <: AbstractElementRegions\n\nBoundary edge region number per boundary edge\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.BFaceGeometries","page":"Extendable grid","title":"ExtendableGrids.BFaceGeometries","text":"Description of boundary face geometries\n\nabstract type BFaceGeometries <: AbstractElementGeometries\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.BFaceNodes","page":"Extendable grid","title":"ExtendableGrids.BFaceNodes","text":"abstract type BFaceNodes <: AbstractGridAdjacency\n\nAdjacency describing nodes per grid boundary face\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.BFaceRegions","page":"Extendable grid","title":"ExtendableGrids.BFaceRegions","text":"abstract type BFaceRegions <: AbstractElementRegions\n\nBoundary region number per boundary face\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.CellGeometries","page":"Extendable grid","title":"ExtendableGrids.CellGeometries","text":"abstract type CellGeometries <: AbstractElementGeometries\n\nDescription of cell geometries\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.CellNodes","page":"Extendable grid","title":"ExtendableGrids.CellNodes","text":"abstract type CellNodes <: AbstractGridAdjacency\n\nAdjacency describing nodes per grid cell\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.CellRegions","page":"Extendable grid","title":"ExtendableGrids.CellRegions","text":"abstract type CellRegions <: AbstractElementRegions\n\nCell region number per cell\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.CoordinateSystem","page":"Extendable grid","title":"ExtendableGrids.CoordinateSystem","text":"abstract type CoordinateSystem <: AbstractGridComponent\n\nCoordinate system\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.Coordinates","page":"Extendable grid","title":"ExtendableGrids.Coordinates","text":"abstract type Coordinates <: AbstractGridFloatArray2D\n\nNode coordinates\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.ExtendableGrid","page":"Extendable grid","title":"ExtendableGrids.ExtendableGrid","text":"mutable struct ExtendableGrid{Tc, Ti}\n\nGrid type wrapping Dict\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.NumBEdgeRegions","page":"Extendable grid","title":"ExtendableGrids.NumBEdgeRegions","text":"abstract type NumBEdgeRegions <: ExtendableGrids.AbstractGridIntegerConstant\n\nNumber of boundary edge regions \n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.NumBFaceRegions","page":"Extendable grid","title":"ExtendableGrids.NumBFaceRegions","text":"abstract type NumBFaceRegions <: ExtendableGrids.AbstractGridIntegerConstant\n\nNumber of boundary face regions \n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#ExtendableGrids.NumCellRegions","page":"Extendable grid","title":"ExtendableGrids.NumCellRegions","text":"abstract type NumCellRegions <: ExtendableGrids.AbstractGridIntegerConstant\n\nNumber of cell regions\n\n\n\n\n\n","category":"type"},{"location":"extendablegrid/#Base.delete!-Tuple{ExtendableGrid, Type{<:AbstractGridComponent}}","page":"Extendable grid","title":"Base.delete!","text":"delete!(\n    grid::ExtendableGrid,\n    T::Type{<:AbstractGridComponent}\n) -> Dict{Type{<:AbstractGridComponent}, Any}\n\n\nRemove grid component\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.get!-Tuple{ExtendableGrid, Type{<:AbstractGridComponent}}","page":"Extendable grid","title":"Base.get!","text":"get!(\n    grid::ExtendableGrid,\n    T::Type{<:AbstractGridComponent}\n) -> Any\n\n\nTo be called by getindex. This triggers lazy creation of  non-existing gridcomponents\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.getindex-Tuple{ExtendableGrid, Type{<:AbstractGridComponent}}","page":"Extendable grid","title":"Base.getindex","text":"Base.getindex(grid::ExtendableGrid,T::Type{<:AbstractGridComponent})\n\nGeneric method for obtaining grid component.\n\nThis method is mutating in the sense that non-existing grid components are created on demand.\n\nDue to the fact that components are stored as Any the return value triggers type instability. To prevent this, specialized methods must be (and are) defined.\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.haskey-Tuple{ExtendableGrid, Any}","page":"Extendable grid","title":"Base.haskey","text":"haskey(g::ExtendableGrid, k) -> Bool\n\n\nCheck if key is in grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.keys-Tuple{ExtendableGrid}","page":"Extendable grid","title":"Base.keys","text":"keys(\n    g::ExtendableGrid\n) -> Base.KeySet{Type{<:AbstractGridComponent}, Dict{Type{<:AbstractGridComponent}, Any}}\n\n\nKeys in grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.map-Tuple{Function, ExtendableGrid}","page":"Extendable grid","title":"Base.map","text":"map(f::Function, grid::ExtendableGrid) -> Any\n\n\nMap a function onto node coordinates of grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#Base.setindex!-Tuple{ExtendableGrid, Any, Type{<:AbstractGridComponent}}","page":"Extendable grid","title":"Base.setindex!","text":"setindex!(\n    grid::ExtendableGrid,\n    v,\n    T::Type{<:AbstractGridComponent}\n) -> Any\n\n\nSet new grid component\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.coord_type-Union{Tuple{ExtendableGrid{Tc, Ti}}, Tuple{Ti}, Tuple{Tc}} where {Tc, Ti}","page":"Extendable grid","title":"ExtendableGrids.coord_type","text":"coord_type(grid)\n\n\nType of coordinates in grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.dim_grid-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.dim_grid","text":"dim_grid(grid)\n\n\nGrid dimension dimension of grid (larges element dimension)\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.dim_space-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.dim_space","text":"dim_space(grid)\n\n\nSpace dimension of grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.gridcomponents-Tuple{}","page":"Extendable grid","title":"ExtendableGrids.gridcomponents","text":"gridcomponents()\n\n\nPrint the hierarchy of grid component key types (subtypes of AbstractGridComponent.  This includes additionally user defined subptypes.\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.index_type-Union{Tuple{ExtendableGrid{Tc, Ti}}, Tuple{Ti}, Tuple{Tc}} where {Tc, Ti}","page":"Extendable grid","title":"ExtendableGrids.index_type","text":"index_type(grid)\n\n\nType of indices\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.instantiate","page":"Extendable grid","title":"ExtendableGrids.instantiate","text":"\"Hook\" for methods instantiating lazy components. \n\n\n\n\n\n","category":"function"},{"location":"extendablegrid/#ExtendableGrids.instantiate-Tuple{Any, Type{NumBEdgeRegions}}","page":"Extendable grid","title":"ExtendableGrids.instantiate","text":"instantiate(grid, _::Type{NumBEdgeRegions}) -> Any\n\n\nInstantiate number of boundary edge regions\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.instantiate-Tuple{Any, Type{NumBFaceRegions}}","page":"Extendable grid","title":"ExtendableGrids.instantiate","text":"instantiate(grid, _::Type{NumBFaceRegions}) -> Any\n\n\nInstantiate number of bface regions\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.instantiate-Tuple{Any, Type{NumCellRegions}}","page":"Extendable grid","title":"ExtendableGrids.instantiate","text":"instantiate(grid, _::Type{NumCellRegions}) -> Any\n\n\nInstantiate number of cell regions\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_bedgeregions-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_bedgeregions","text":"num_bedgeregions(grid::ExtendableGrid) -> Any\n\n\nMaximum boundary edge region numbers\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_bedges-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_bedges","text":"num_bedges(grid::ExtendableGrid) -> Int64\n\n\nNumber of boundary edges in grid.\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_bfaceregions-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_bfaceregions","text":"num_bfaceregions(grid::ExtendableGrid) -> Any\n\n\nMaximum  boundary face region numbers\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_bfaces-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_bfaces","text":"num_bfaces(grid::ExtendableGrid) -> Int64\n\n\nNumber of boundary faces in grid.\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_cellregions-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_cellregions","text":"num_cellregions(grid::ExtendableGrid) -> Any\n\n\nMaximum  cell  region number\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_cells-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_cells","text":"num_cells(grid::ExtendableGrid) -> Int64\n\n\nNumber of cells in grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.num_nodes-Tuple{ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.num_nodes","text":"num_nodes(grid)\n\n\nNumber of nodes in grid\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.seemingly_equal-Tuple{AbstractArray, AbstractArray}","page":"Extendable grid","title":"ExtendableGrids.seemingly_equal","text":"seemingly_equal(array1, array2)\n\n\nCheck for seeming equality of two arrays by random sample.\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.seemingly_equal-Tuple{ExtendableGrid, ExtendableGrid}","page":"Extendable grid","title":"ExtendableGrids.seemingly_equal","text":"seemingly_equal(grid1, grid2; sort=false, confidence=:full\n\nRecursively check seeming equality of two grids. Seemingly means  that long arrays are only compared via random samples.\n\nKeyword args:\n\nsort: if true, sort grid points\nconfidence:  Confidence level: \n:low : Point numbers etc are the same\n:full : all arrays are equal (besides the coordinate array, the arrays only have to be equal up to permutations)\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.veryform-Tuple{ExtendableGrid, Any, Type{<:AbstractGridComponent}}","page":"Extendable grid","title":"ExtendableGrids.veryform","text":"veryform(\n    grid::ExtendableGrid,\n    v,\n    _::Type{<:AbstractGridComponent}\n) -> Any\n\n\nDefault veryform method.\n\n\"veryform\"  means \"verify and/or transform\"  and is called to check and possibly transform components to be added to the grid via setindex!.\n\nThe default method just passes data through.\n\n\n\n\n\n","category":"method"},{"location":"extendablegrid/#ExtendableGrids.veryform-Union{Tuple{Ti}, Tuple{Tc}, Tuple{ExtendableGrid{Tc, Ti}, Any, Type{<:AbstractGridAdjacency}}} where {Tc, Ti}","page":"Extendable grid","title":"ExtendableGrids.veryform","text":"veryform(grid::ExtendableGrid{Tc,Ti},v,T::Type{<:AbstractGridAdjacency}) where{Tc,Ti}\n\nCheck proper type of adjacencies upon insertion\n\n\n\n\n\n","category":"method"},{"location":"typehierarchy/#Type-hierarchy","page":"Type hierarchy","title":"Type hierarchy","text":"","category":"section"},{"location":"typehierarchy/","page":"Type hierarchy","title":"Type hierarchy","text":"The package defines a hierarchy of abstract types to handle grid compoments. The full tree is listed here:","category":"page"},{"location":"typehierarchy/","page":"Type hierarchy","title":"Type hierarchy","text":"using ExtendableGrids # hide\ntypehierarchy() #hide","category":"page"},{"location":"typehierarchy/#API","page":"Type hierarchy","title":"API","text":"","category":"section"},{"location":"typehierarchy/","page":"Type hierarchy","title":"Type hierarchy","text":"Modules = [ExtendableGrids]\nPages = [\"typehierarchy.jl\"]","category":"page"},{"location":"typehierarchy/#ExtendableGrids.AbstractExtendableGridApexType","page":"Type hierarchy","title":"ExtendableGrids.AbstractExtendableGridApexType","text":"abstract type AbstractExtendableGridApexType\n\nApex type of all abstract types in this hierarchy.\n\n\n\n\n\n","category":"type"},{"location":"typehierarchy/#AbstractTrees.children-Tuple{Type}","page":"Type hierarchy","title":"AbstractTrees.children","text":"children(T::Type) -> Union{Vector{Type}, Vector{Any}}\n\n\nDefine children for types.\n\n\n\n\n\n","category":"method"},{"location":"typehierarchy/#ExtendableGrids.typehierarchy-Tuple{}","page":"Type hierarchy","title":"ExtendableGrids.typehierarchy","text":"typehierarchy()\n\n\nPrint complete type hierachy for ExtendableGrids\n\n\n\n\n\n","category":"method"},{"location":"examples/examples1d/#D-Grid-examples","page":"1D Grid examples","title":"1D Grid examples","text":"","category":"section"},{"location":"examples/examples1d/","page":"1D Grid examples","title":"1D Grid examples","text":"using ExtendableGrids","category":"page"},{"location":"examples/examples1d/#Interval-from-vector","page":"1D Grid examples","title":"Interval from vector","text":"","category":"section"},{"location":"examples/examples1d/","page":"1D Grid examples","title":"1D Grid examples","text":"function interval_from_vector()\n    X=collect(0:0.05:1)\n    grid=simplexgrid(X)\nend","category":"page"},{"location":"examples/examples1d/","page":"1D Grid examples","title":"1D Grid examples","text":"(Image: )","category":"page"},{"location":"examples/examples1d/","page":"1D Grid examples","title":"1D Grid examples","text":"##Interval with local refinement","category":"page"},{"location":"examples/examples1d/","page":"1D Grid examples","title":"1D Grid examples","text":"function interval_localref()\n\n    XLeft=geomspace(0.0,0.5,0.1, 0.01)\n    XRight=geomspace(0.5,1.0,0.01,0.1)\n    X=glue(XLeft, XRight)\n    grid=simplexgrid(X)\nend","category":"page"},{"location":"examples/examples1d/","page":"1D Grid examples","title":"1D Grid examples","text":"(Image: )","category":"page"},{"location":"examples/examples1d/#Interval-with-multiple-regions","page":"1D Grid examples","title":"Interval with  multiple regions","text":"","category":"section"},{"location":"examples/examples1d/","page":"1D Grid examples","title":"1D Grid examples","text":"function interval_multiregion()\n\n    X=collect(0:0.05:1)\n    grid=simplexgrid(X)\n    cellmask!(grid,[0.0],[0.5],3)\n    bfacemask!(grid,[0.5], [0.5],4)\n    grid\nend","category":"page"},{"location":"examples/examples1d/","page":"1D Grid examples","title":"1D Grid examples","text":"(Image: )","category":"page"},{"location":"examples/examples1d/#Multiple-regions-and-subgrid","page":"1D Grid examples","title":"Multiple regions and subgrid","text":"","category":"section"},{"location":"examples/examples1d/","page":"1D Grid examples","title":"1D Grid examples","text":"function interval_subgrid()\n    X=collect(0:0.01:1)\n    grid=simplexgrid(X)\n    bfacemask!(grid,[0.5],[0.5],3)\n    cellmask!(grid,[0.0],[0.25],2)\n    cellmask!(grid,[0.20],[0.5],3)\n    subgrid(grid,[2,3])\nend","category":"page"},{"location":"examples/examples1d/","page":"1D Grid examples","title":"1D Grid examples","text":"(Image: )","category":"page"},{"location":"examples/examples1d/","page":"1D Grid examples","title":"1D Grid examples","text":"","category":"page"},{"location":"examples/examples1d/","page":"1D Grid examples","title":"1D Grid examples","text":"This page was generated using Literate.jl.","category":"page"},{"location":"vectorofconstants/#Vector-of-constants","page":"Vector of constants","title":"Vector of constants","text":"","category":"section"},{"location":"vectorofconstants/","page":"Vector of constants","title":"Vector of constants","text":"Datatype to store vector with a constant value.","category":"page"},{"location":"vectorofconstants/#API","page":"Vector of constants","title":"API","text":"","category":"section"},{"location":"vectorofconstants/","page":"Vector of constants","title":"Vector of constants","text":"Modules = [ExtendableGrids]\nPages = [\"vectorofconstants.jl\"]","category":"page"},{"location":"vectorofconstants/#ExtendableGrids.VectorOfConstants","page":"Vector of constants","title":"ExtendableGrids.VectorOfConstants","text":"struct VectorOfConstants{T, Tl} <: AbstractArray{T, 1}\n\nVector with constant value\n\n\n\n\n\n","category":"type"},{"location":"vectorofconstants/#Base.getindex-Tuple{VectorOfConstants, Any}","page":"Vector of constants","title":"Base.getindex","text":"getindex(v::VectorOfConstants, i) -> Any\n\n\nAccess\n\n\n\n\n\n","category":"method"},{"location":"vectorofconstants/#Base.iterate-Tuple{VectorOfConstants, Any}","page":"Vector of constants","title":"Base.iterate","text":"iterate(\n    v::VectorOfConstants,\n    state\n) -> Union{Nothing, Tuple{Any, Any}}\n\n\nIterator\n\n\n\n\n\n","category":"method"},{"location":"vectorofconstants/#Base.iterate-Tuple{VectorOfConstants}","page":"Vector of constants","title":"Base.iterate","text":"iterate(v::VectorOfConstants) -> Tuple{Any, Int64}\n\n\nIterator\n\n\n\n\n\n","category":"method"},{"location":"vectorofconstants/#Base.length-Tuple{VectorOfConstants}","page":"Vector of constants","title":"Base.length","text":"length(v::VectorOfConstants) -> Any\n\n\nLength\n\n\n\n\n\n","category":"method"},{"location":"vectorofconstants/#Base.size-Tuple{VectorOfConstants}","page":"Vector of constants","title":"Base.size","text":"size(v::VectorOfConstants) -> Tuple{Any}\n\n\nSize\n\n\n\n\n\n","category":"method"},{"location":"vectorofconstants/#Base.unique-Tuple{VectorOfConstants}","page":"Vector of constants","title":"Base.unique","text":"unique(v::VectorOfConstants) -> Vector\n\n\nShortcut for unique\n\n\n\n\n\n","category":"method"},{"location":"elementgeometry/#Element-geometry","page":"Element geometry","title":"Element geometry","text":"","category":"section"},{"location":"elementgeometry/","page":"Element geometry","title":"Element geometry","text":"Element geometries are described via abstract types. The list of element geometries systems can be obtained with the elementgeometries method:","category":"page"},{"location":"elementgeometry/","page":"Element geometry","title":"Element geometry","text":"using ExtendableGrids # hide\nelementgeometries() #hide","category":"page"},{"location":"elementgeometry/#API","page":"Element geometry","title":"API","text":"","category":"section"},{"location":"elementgeometry/","page":"Element geometry","title":"Element geometry","text":"Modules = [ExtendableGrids]\nPages = [\"elementgeometry.jl\"]","category":"page"},{"location":"elementgeometry/#ExtendableGrids.AbstractElementGeometry","page":"Element geometry","title":"ExtendableGrids.AbstractElementGeometry","text":"abstract type AbstractElementGeometry <: AbstractExtendableGridApexType\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.AbstractElementGeometry0D","page":"Element geometry","title":"ExtendableGrids.AbstractElementGeometry0D","text":"abstract type AbstractElementGeometry0D <: AbstractElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.AbstractElementGeometry1D","page":"Element geometry","title":"ExtendableGrids.AbstractElementGeometry1D","text":"abstract type AbstractElementGeometry1D <: AbstractElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.AbstractElementGeometry2D","page":"Element geometry","title":"ExtendableGrids.AbstractElementGeometry2D","text":"abstract type AbstractElementGeometry2D <: AbstractElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.AbstractElementGeometry3D","page":"Element geometry","title":"ExtendableGrids.AbstractElementGeometry3D","text":"abstract type AbstractElementGeometry3D <: AbstractElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.AbstractElementGeometry4D","page":"Element geometry","title":"ExtendableGrids.AbstractElementGeometry4D","text":"abstract type AbstractElementGeometry4D <: AbstractElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Circle2D","page":"Element geometry","title":"ExtendableGrids.Circle2D","text":"abstract type Circle2D <: AbstractElementGeometry2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Edge1D","page":"Element geometry","title":"ExtendableGrids.Edge1D","text":"abstract type Edge1D <: AbstractElementGeometry1D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Hexagon2D","page":"Element geometry","title":"ExtendableGrids.Hexagon2D","text":"abstract type Hexagon2D <: Polygon2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Hexahedron3D","page":"Element geometry","title":"ExtendableGrids.Hexahedron3D","text":"abstract type Hexahedron3D <: Polyhedron3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.HyperCube4D","page":"Element geometry","title":"ExtendableGrids.HyperCube4D","text":"abstract type HyperCube4D <: AbstractElementGeometry4D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Parallelepiped3D","page":"Element geometry","title":"ExtendableGrids.Parallelepiped3D","text":"abstract type Parallelepiped3D <: Hexahedron3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Parallelogram2D","page":"Element geometry","title":"ExtendableGrids.Parallelogram2D","text":"abstract type Parallelogram2D <: Quadrilateral2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Pentagon2D","page":"Element geometry","title":"ExtendableGrids.Pentagon2D","text":"abstract type Pentagon2D <: Polygon2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Polychoron4D","page":"Element geometry","title":"ExtendableGrids.Polychoron4D","text":"abstract type Polychoron4D <: AbstractElementGeometry4D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Polygon2D","page":"Element geometry","title":"ExtendableGrids.Polygon2D","text":"abstract type Polygon2D <: AbstractElementGeometry2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Polyhedron3D","page":"Element geometry","title":"ExtendableGrids.Polyhedron3D","text":"abstract type Polyhedron3D <: AbstractElementGeometry3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Prism3D","page":"Element geometry","title":"ExtendableGrids.Prism3D","text":"abstract type Prism3D <: Polyhedron3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Quadrilateral2D","page":"Element geometry","title":"ExtendableGrids.Quadrilateral2D","text":"abstract type Quadrilateral2D <: Polygon2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Rectangle2D","page":"Element geometry","title":"ExtendableGrids.Rectangle2D","text":"abstract type Rectangle2D <: Parallelogram2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.RectangularCuboid3D","page":"Element geometry","title":"ExtendableGrids.RectangularCuboid3D","text":"abstract type RectangularCuboid3D <: Parallelepiped3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Sphere3D","page":"Element geometry","title":"ExtendableGrids.Sphere3D","text":"abstract type Sphere3D <: AbstractElementGeometry3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Tetrahedron3D","page":"Element geometry","title":"ExtendableGrids.Tetrahedron3D","text":"abstract type Tetrahedron3D <: Polyhedron3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Triangle2D","page":"Element geometry","title":"ExtendableGrids.Triangle2D","text":"abstract type Triangle2D <: Polygon2D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.TrianglePrism3D","page":"Element geometry","title":"ExtendableGrids.TrianglePrism3D","text":"abstract type TrianglePrism3D <: Prism3D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.Vertex0D","page":"Element geometry","title":"ExtendableGrids.Vertex0D","text":"abstract type Vertex0D <: AbstractElementGeometry0D\n\n\n\n\n\n","category":"type"},{"location":"elementgeometry/#ExtendableGrids.dim_element-Tuple{Type{<:AbstractElementGeometry0D}}","page":"Element geometry","title":"ExtendableGrids.dim_element","text":"dim_element(_::Type{<:AbstractElementGeometry0D}) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"elementgeometry/#ExtendableGrids.dim_element-Tuple{Type{<:AbstractElementGeometry1D}}","page":"Element geometry","title":"ExtendableGrids.dim_element","text":"dim_element(_::Type{<:AbstractElementGeometry1D}) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"elementgeometry/#ExtendableGrids.dim_element-Tuple{Type{<:AbstractElementGeometry2D}}","page":"Element geometry","title":"ExtendableGrids.dim_element","text":"dim_element(_::Type{<:AbstractElementGeometry2D}) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"elementgeometry/#ExtendableGrids.dim_element-Tuple{Type{<:AbstractElementGeometry3D}}","page":"Element geometry","title":"ExtendableGrids.dim_element","text":"dim_element(_::Type{<:AbstractElementGeometry3D}) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"elementgeometry/#ExtendableGrids.dim_element-Tuple{Type{<:AbstractElementGeometry4D}}","page":"Element geometry","title":"ExtendableGrids.dim_element","text":"dim_element(_::Type{<:AbstractElementGeometry4D}) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"elementgeometry/#ExtendableGrids.elementgeometries-Tuple{}","page":"Element geometry","title":"ExtendableGrids.elementgeometries","text":"elementgeometries()\n\n\nList supported element geometries.\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#Token-streams","page":"Token streams","title":"Token streams","text":"","category":"section"},{"location":"tokenstream/","page":"Token streams","title":"Token streams","text":"The TokenStream struct supports reading of tokenizable ASCII files","category":"page"},{"location":"tokenstream/#API","page":"Token streams","title":"API","text":"","category":"section"},{"location":"tokenstream/","page":"Token streams","title":"Token streams","text":"Modules = [ExtendableGrids]\nPages = [\"tokenstream.jl\"]","category":"page"},{"location":"tokenstream/#ExtendableGrids.TokenStream","page":"Token streams","title":"ExtendableGrids.TokenStream","text":"mutable struct TokenStream\n\nTokenstream allows to read tokenized data from file without keeping the file ocntent in memory.\n\ninput::IOStream: Input stream\n\ntokens::Vector{SubString{String}}: Array of current tokens kept in memory.\n\nitoken::Int64: Position of actual token in tokens array\n\nlineno::Int64: Line number in IOStream\n\ncomment::Char: Comment character\n\ndlm::Function: Function telling if given character is a delimiter.\n\n\n\n\n\n","category":"type"},{"location":"tokenstream/#ExtendableGrids.TokenStream-Tuple{IOStream}","page":"Token streams","title":"ExtendableGrids.TokenStream","text":"TokenStream(input::IOStream; comment, dlm) -> TokenStream\n\n\nCreate Tokenstream with IOStream argument.\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#ExtendableGrids.TokenStream-Tuple{String}","page":"Token streams","title":"ExtendableGrids.TokenStream","text":"TokenStream(filename::String; comment, dlm) -> TokenStream\n\n\nCreate Tokenstream with file name argument.\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#ExtendableGrids.UnexpectedTokenError","page":"Token streams","title":"ExtendableGrids.UnexpectedTokenError","text":"struct UnexpectedTokenError <: Exception\n\nError thrown when the token expected  in expect!  is not there.\n\nfound::String\nexpected::String\nlineno::Int64\n\n\n\n\n\n","category":"type"},{"location":"tokenstream/#Base.eof-Tuple{TokenStream}","page":"Token streams","title":"Base.eof","text":"eof(tks::TokenStream) -> Bool\n\n\nCheck if all tokens have been consumed.\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#ExtendableGrids.destruct!-Tuple{TokenStream}","page":"Token streams","title":"ExtendableGrids.destruct!","text":"destruct!(tks::TokenStream)\n\n\nTokenstream destructor should close input\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#ExtendableGrids.expecttoken-Tuple{TokenStream, String}","page":"Token streams","title":"ExtendableGrids.expecttoken","text":"expecttoken(tks::TokenStream, expected::String) -> Bool\n\n\nExpect keyword token.\n\nIf token is missing, an UnexpectedTokenError is thrown If the token  has been found, reading will continue  at the position after the token found.\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#ExtendableGrids.gettoken-Tuple{TokenStream}","page":"Token streams","title":"ExtendableGrids.gettoken","text":"gettoken(\n    tks::TokenStream\n) -> Union{Nothing, SubString{String}}\n\n\nGet next token from tokenstream.\n\n\n\n\n\n","category":"method"},{"location":"tokenstream/#ExtendableGrids.trytoken-Tuple{TokenStream, String}","page":"Token streams","title":"ExtendableGrids.trytoken","text":"trytoken(tks::TokenStream, expected::String) -> Bool\n\n\nTry for keyword token.\n\nIt token is missing, the token read is put back into stream, a value of false is returned and the next try/gettoken command continues at the same position,\n\nOtherwise, true is returned, and reading continues after the token found.\n\n\n\n\n\n","category":"method"},{"location":"arraytools/#Array-tools","page":"Array tools","title":"Array tools","text":"","category":"section"},{"location":"arraytools/#API","page":"Array tools","title":"API","text":"","category":"section"},{"location":"arraytools/","page":"Array tools","title":"Array tools","text":"Modules = [ExtendableGrids]\nPages = [\"arraytools.jl\"]","category":"page"},{"location":"arraytools/#ExtendableGrids.geomspace-NTuple{4, Any}","page":"Array tools","title":"ExtendableGrids.geomspace","text":"geomspace(a, b, ha, hb; tol, maxiterations) -> Any\n\n\n(Try to) create a subdivision of interval (a,b) stored in the  returned array X such that \n\nX[1]==a, X[end]==b\n(X[2]-X[1])<=ha+tol*(b-a)\n(X[end]-X[end-1])<=hb+tol*(b-a)\nThere is a number q such that  X[i+1]-X[i] == q*(X[i]-X[i-1])\nX is the array with the minimal possible number of points with the above property\n\nCaveat: the algorithm behind this is  tested for many cases but unproven.\n\nReturns an Array containing the points of the subdivision.\n\n\n\n\n\n","category":"method"},{"location":"arraytools/#ExtendableGrids.glue-Tuple{AbstractVector, AbstractVector}","page":"Array tools","title":"ExtendableGrids.glue","text":"c=glue(a,b)\n\nGlue together two vectors a and b resulting in a vector c. They last element  of a shall be equal (up to tol) to the first element of b. The result fulfills length(c)=length(a)+length(b)-1\n\n\n\n\n\n","category":"method"},{"location":"arraytools/#ExtendableGrids.linspace-Tuple{Any, Any, Any}","page":"Array tools","title":"ExtendableGrids.linspace","text":"linspace(a, b, n) -> Any\n\n\nResurrect linspace despite https://github.com/JuliaLang/julia/pull/25896#issuecomment-363769368\n\n\n\n\n\n","category":"method"},{"location":"regionedit/#Region-editing","page":"Region editing","title":"Region editing","text":"","category":"section"},{"location":"regionedit/","page":"Region editing","title":"Region editing","text":"Tools for editing grid region numbers","category":"page"},{"location":"regionedit/","page":"Region editing","title":"Region editing","text":"cellmask!\nbfacemask!\nrect!\nbedgemask!","category":"page"},{"location":"regionedit/#ExtendableGrids.cellmask!","page":"Region editing","title":"ExtendableGrids.cellmask!","text":"cellmask!(\n    grid::ExtendableGrid,\n    maskmin,\n    maskmax,\n    ireg::Int64;\n    tol\n) -> ExtendableGrid\n\n\nEdit region numbers of grid cells via rectangular mask.\n\nExamples: Rectangle-with-multiple-regions\n\n\n\n\n\n","category":"function"},{"location":"regionedit/#ExtendableGrids.bfacemask!","page":"Region editing","title":"ExtendableGrids.bfacemask!","text":"bfacemask!(grid::ExtendableGrid,\n                maskmin,\n                maskmax,\n                ireg;\n                allow_new=true,\n                tol=1.0e-10)\n\nEdit region numbers of grid  boundary facets  via rectangular mask. If allow_new is true (default), new facets are added.\n\nireg may be an integer  or a function ireg(current_region).\n\nA zero region number removes boundary faces.\n\nExamples: Rectangle-with-multiple-regions\n\n\n\n\n\n","category":"function"},{"location":"regionedit/#ExtendableGrids.rect!","page":"Region editing","title":"ExtendableGrids.rect!","text":"rect!(grid,maskmin,maskmax; \n      region=1, \n      bregion=1, \n      bregions=nothing, \n      tol=1.0e-10)\n\nPlace a rectangle into a rectangular grid. It places a cellmask according to maskmin and maskmax, and introduces boundary faces via `bfacesmask! at all sides of the mask area. It is checked that the coordinate values in the mask match (with tolerance) corresponding directional coordinates of the grid.\n\nIf bregions is given it is assumed to be a vector corresponding to the number of sides, im the sequence w,e in 1D. s,e,n,w in 2D and s,e,n,w,b,t in 3D.\n\nbregion or elements of bregions can be numbers or functions ireg(current_region).\n\nExamples: Subgrid-from-rectangle, Rect2d-with-bregion-function,  Cross3d\n\n\n\n\n\n","category":"function"},{"location":"regionedit/#ExtendableGrids.bedgemask!","page":"Region editing","title":"ExtendableGrids.bedgemask!","text":"bedgemask!(\n    grid::ExtendableGrid,\n    xa,\n    xb,\n    ireg::Int64;\n    tol\n) -> ExtendableGrid\n\n\nEdit region numbers of grid  boundary edges via line mask. This only works for 3D grids.\n\n\n\n\n\n","category":"function"},{"location":"cellfinder/#Search-and-Interpolation","page":"Search and Interpolation","title":"Search and Interpolation","text":"","category":"section"},{"location":"cellfinder/#Search","page":"Search and Interpolation","title":"Search","text":"","category":"section"},{"location":"cellfinder/","page":"Search and Interpolation","title":"Search and Interpolation","text":"CellFinder\ngFindLocal!\ngFindBruteForce!","category":"page"},{"location":"cellfinder/#ExtendableGrids.CellFinder","page":"Search and Interpolation","title":"ExtendableGrids.CellFinder","text":"struct CellFinder{Tv, Ti}\n\nCellFinder supports finding cells in grids.\n\n\n\n\n\n","category":"type"},{"location":"cellfinder/#ExtendableGrids.gFindLocal!","page":"Search and Interpolation","title":"ExtendableGrids.gFindLocal!","text":"icellfound=GFindLocal!(xref,cellfinder,p; icellstart=1,eps=1.0e-14, trybrute=true)\n\nFind cell containing point p  starting with cell number icellstart.\n\nReturns cell number if found, zero otherwise. If trybrute==true try gFindBruteForce! before giving up. Upon return, xref contains the barycentric coordinates of the point in the sequence  dim+1, 1...dim\n\nwarning: Warning\nCurrently implemented for simplex grids only.\n\n\n\n\n\n","category":"function"},{"location":"cellfinder/#ExtendableGrids.gFindBruteForce!","page":"Search and Interpolation","title":"ExtendableGrids.gFindBruteForce!","text":"icellfound=gFindBruteForce!(xref,cellfinder,p; icellstart=1,eps=1.0e-14)\n\nFind cell containing point p  starting with cell number icellstart.\n\nReturns cell number if found, zero otherwise. Upon return, xref contains the barycentric coordinates of the point in the sequence  dim+1, 1...dim\n\nwarning: Warning\nCurrently implemented for simplex grids only.\n\n\n\n\n\n","category":"function"},{"location":"cellfinder/#Interpolation","page":"Search and Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"cellfinder/","page":"Search and Interpolation","title":"Search and Interpolation","text":"interpolate\ninterpolate!","category":"page"},{"location":"cellfinder/#ExtendableGrids.interpolate","page":"Search and Interpolation","title":"ExtendableGrids.interpolate","text":"u_to=interpolate(grid_to, u_from, grid_from;eps=1.0e-14,trybrute=true)\n\nPiecewise linear interpolation of function u_from on grid grid_from to grid_to. Works for matrices with second dimension corresponding to grid nodes and for vectors.\n\nwarning: Warning\nMay be slow on non-convex domains. If trybrute==false it may even fail.\n\nwarning: Warning\nCurrently implemented for simplex grids only.\n\n\n\n\n\n","category":"function"},{"location":"cellfinder/#ExtendableGrids.interpolate!","page":"Search and Interpolation","title":"ExtendableGrids.interpolate!","text":"interpolate!(u_to,grid_to, u_from, grid_from;eps=1.0e-14,trybrute=true)\n\nMutating form of interpolate\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#Gmsh-interoperability","page":"Gmsh interoperability","title":"Gmsh interoperability","text":"","category":"section"},{"location":"gmsh/","page":"Gmsh interoperability","title":"Gmsh interoperability","text":"This functionality is in beta stage. Breaking changes for this API are considered non-breaking for the package. Therefore, these functions are not exported yet.","category":"page"},{"location":"gmsh/#API","page":"Gmsh interoperability","title":"API","text":"","category":"section"},{"location":"gmsh/","page":"Gmsh interoperability","title":"Gmsh interoperability","text":"These methods become available via a package extension which is loaded together with  Gmsh.jl. See the general gmsh documentation, the Gmsh reference manual and the Gmsh Julia API source code for  information.","category":"page"},{"location":"gmsh/","page":"Gmsh interoperability","title":"Gmsh interoperability","text":"ExtendableGrids.simplexgrid_from_gmsh\nExtendableGrids.simplexgrid_to_gmsh\nExtendableGrids.mixedgrid_from_gmsh\nExtendableGrids.mixedgrid_to_gmsh","category":"page"},{"location":"gmsh/#ExtendableGrids.simplexgrid_from_gmsh","page":"Gmsh interoperability","title":"ExtendableGrids.simplexgrid_from_gmsh","text":"simplexgrid_from_gmsh(filename::String; incomplete=false, Tc=Float32, Ti=Int32)\n\nThe msh file is read and a SimplexGrid is created. The mesh can also contain an incomplete grid. For this, the function has to be called with incomplete=true. 'incomplete' means that the grid only consists of nodes and cells, it does not have a boundary. We also do not try to read the physical groups for those grids. Tc is the type of coordinates, Ti is the index type.\n\n\n\n\n\nsimplexgrid_from_gmsh(mod::Module; incomplete=false, Tc=Float32, Ti=Int32)\n\nThe mesh contained in the gmsh module is converted to a SimplexGrid. The mesh can also contain an incomplete grid. For this, the function has to be called with incomplete=true. 'incomplete' means that the grid only consists of nodes and cells, it does not have a boundary. We also do not try to read the physical groups for those grids. Tc is the type of coordinates, Ti is the index type.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGrids.simplexgrid_to_gmsh","page":"Gmsh interoperability","title":"ExtendableGrids.simplexgrid_to_gmsh","text":"simplexgrid_to_gmsh(g::ExtendableGrid; filename::String=\"\")\n\nThe SimplexGrid 'g' is loaded into a gmsh module. If a string (not \"\") is passed via 'filename', the mesh is written into this file.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGrids.mixedgrid_from_gmsh","page":"Gmsh interoperability","title":"ExtendableGrids.mixedgrid_from_gmsh","text":"mixedgrid_from_gmsh(filename::String; Tc=Float32, Ti=Int32)\n\nThe msh file is read and an ExtendableGrid is created. This only works for dim=2 grids and the orientation may be wrong. Tc is the type of coordinates, Ti is the index type.\n\n\n\n\n\nmixedgrid_from_gmsh(mod::Module; Tc=Float32, Ti=Int32)\n\nThe mesh contained in the gmsh module is converted to an ExtendableGrid. Tc is the type of coordinates, Ti is the index type.\n\n\n\n\n\n","category":"function"},{"location":"gmsh/#ExtendableGrids.mixedgrid_to_gmsh","page":"Gmsh interoperability","title":"ExtendableGrids.mixedgrid_to_gmsh","text":"mixedgrid_to_gmsh(g::ExtendableGrid; filename::String=\"\")\n\nThe ExtendableGrid 'g' is loaded into a gmsh module. If a string (not \"\") is passed via 'filename', the mesh is written into this file.\n\n\n\n\n\n","category":"function"},{"location":"subgrid/#Subgrid","page":"Subgrid","title":"Subgrid","text":"","category":"section"},{"location":"subgrid/","page":"Subgrid","title":"Subgrid","text":"Subgrids of an ExtendableGrid are again of the same type ExtendableGrid and unse the typed Dict mechanism to store linkage to the parent grid.","category":"page"},{"location":"subgrid/","page":"Subgrid","title":"Subgrid","text":"using ExtendableGrids # hide\ngrid=simplexgrid([1,2,3], [4,5,6])\nsub=subgrid(grid,[2],boundary=true, transform=(a,b) -> (a[1]=10*b[2]))\nprintln(keys(sub))\nprintln(sub[Coordinates])","category":"page"},{"location":"subgrid/","page":"Subgrid","title":"Subgrid","text":"Given a vector on the parent grid, one can create a view of this vecotor on the subgrid:","category":"page"},{"location":"subgrid/","page":"Subgrid","title":"Subgrid","text":"using ExtendableGrids # hide\ngrid=simplexgrid([1,2,3], [4,5,6])\nsub=subgrid(grid,[2],boundary=true, transform=(a,b) -> (a[1]=10*b[2]))\nv=[i for i=1:num_nodes(grid)]\nsubv=view(v,sub)\nprintln(subv)","category":"page"},{"location":"subgrid/#API","page":"Subgrid","title":"API","text":"","category":"section"},{"location":"subgrid/","page":"Subgrid","title":"Subgrid","text":"Modules = [ExtendableGrids]\nPages = [\"subgrid.jl\"]","category":"page"},{"location":"subgrid/#ExtendableGrids.NodeInParent","page":"Subgrid","title":"ExtendableGrids.NodeInParent","text":"abstract type NodeInParent <: AbstractGridIntegerArray1D\n\nGrid component key type for storing node in parent array\n\n\n\n\n\n","category":"type"},{"location":"subgrid/#ExtendableGrids.ParentGrid","page":"Subgrid","title":"ExtendableGrids.ParentGrid","text":"abstract type ParentGrid <: AbstractGridComponent\n\nGrid component key type for storing parent grid\n\n\n\n\n\n","category":"type"},{"location":"subgrid/#ExtendableGrids.SubgridVectorView","page":"Subgrid","title":"ExtendableGrids.SubgridVectorView","text":"struct SubgridVectorView{Tv, Ti} <: AbstractArray{Tv, 1}\n\nVector view on subgrid\n\nsysarray::AbstractVector\nnode_in_parent::Vector\n\n\n\n\n\n","category":"type"},{"location":"subgrid/#Base.getindex-Tuple{ExtendableGrids.SubgridVectorView, Integer}","page":"Subgrid","title":"Base.getindex","text":"getindex(\n    aview::ExtendableGrids.SubgridVectorView,\n    inode::Integer\n) -> Any\n\n\nAccessor method for subgrid vector view.\n\n\n\n\n\n","category":"method"},{"location":"subgrid/#Base.setindex!-Tuple{ExtendableGrids.SubgridVectorView, Any, Integer}","page":"Subgrid","title":"Base.setindex!","text":"setindex!(\n    aview::ExtendableGrids.SubgridVectorView,\n    v,\n    inode::Integer\n) -> ExtendableGrids.SubgridVectorView\n\n\nAccessor method for subgrid vector view.\n\n\n\n\n\n","category":"method"},{"location":"subgrid/#Base.size-Tuple{ExtendableGrids.SubgridVectorView}","page":"Subgrid","title":"Base.size","text":"size(a::ExtendableGrids.SubgridVectorView) -> Tuple{Int64}\n\n\nReturn size of vector view.\n\n\n\n\n\n","category":"method"},{"location":"subgrid/#Base.view-Tuple{AbstractVector, ExtendableGrid}","page":"Subgrid","title":"Base.view","text":"view(\n    a::AbstractVector,\n    subgrid::ExtendableGrid\n) -> ExtendableGrids.SubgridVectorView\n\n\nCreate a view of the vector on a subgrid.\n\n\n\n\n\n","category":"method"},{"location":"subgrid/#ExtendableGrids._copytransform!-Tuple{AbstractArray, AbstractArray}","page":"Subgrid","title":"ExtendableGrids._copytransform!","text":"_copytransform!(a::AbstractArray, b::AbstractArray)\n\n\nDefault transform for subgrid creation\n\n\n\n\n\n","category":"method"},{"location":"subgrid/#ExtendableGrids.subgrid-Tuple{Any, AbstractArray}","page":"Subgrid","title":"ExtendableGrids.subgrid","text":"subgrid(\n    parent,\n    subregions::AbstractArray;\n    transform,\n    boundary,\n    project\n) -> ExtendableGrid\n\n\nCreate subgrid from list of regions.\n\nparent: parent grid \nsubregions:  Array of subregions\ntransform (kw parameter): transformation function between  grid and subgrid coordinates acting on one point.  Default: copytransform\nboundary: if true, create codimension 1 subgrid from boundary region.\nproject: project coordinates onto  subgrid dimension\n\nA subgrid is of type ExtendableGrid and stores two additional components: ParentGrid and NodeInParent\n\n\n\n\n\n","category":"method"},{"location":"more/#Derived-adjacencies","page":"Derived adjacencies","title":"Derived adjacencies","text":"","category":"section"},{"location":"more/#API","page":"Derived adjacencies","title":"API","text":"","category":"section"},{"location":"more/","page":"Derived adjacencies","title":"Derived adjacencies","text":"Modules = [ExtendableGrids]\nPages = [\"derived.jl\",\"more.jl\"]","category":"page"},{"location":"more/#ExtendableGrids.BFaceCells","page":"Derived adjacencies","title":"ExtendableGrids.BFaceCells","text":"abstract type BFaceCells <: AbstractGridAdjacency\n\nAdjacency describing cells per boundary or interior face\n\n\n\n\n\n","category":"type"},{"location":"more/#ExtendableGrids.BFaceEdges","page":"Derived adjacencies","title":"ExtendableGrids.BFaceEdges","text":"abstract type BFaceEdges <: AbstractGridAdjacency\n\nAdjacency describing edges per boundary or interior face\n\n\n\n\n\n","category":"type"},{"location":"more/#ExtendableGrids.BFaceNormals","page":"Derived adjacencies","title":"ExtendableGrids.BFaceNormals","text":"abstract type BFaceNormals <: AbstractGridComponent\n\nAdjacency describing outer normals to boundary faces\n\n\n\n\n\n","category":"type"},{"location":"more/#ExtendableGrids.prepare_edges!-Tuple{ExtendableGrid}","page":"Derived adjacencies","title":"ExtendableGrids.prepare_edges!","text":"prepare_edges!(grid)\n\n\nPrepare edge adjacencies (celledges, edgecells, edgenodes)\n\nCurrently depends on ExtendableSparse, we may want to remove this adjacency.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"},{"location":"examples/examples3d/#D-Grid-examples","page":"3D Grid examples","title":"3D Grid examples","text":"","category":"section"},{"location":"examples/examples3d/#Quadrilateral","page":"3D Grid examples","title":"Quadrilateral","text":"","category":"section"},{"location":"examples/examples3d/","page":"3D Grid examples","title":"3D Grid examples","text":"function quadrilateral(;hx=0.25, hy=0.2, hz=0.1)\n    X=collect(0:hx:1)\n    Y=collect(0:hy:1)\n    Z=collect(0:hz:1)\n    simplexgrid(X,Y,Z)\nend","category":"page"},{"location":"examples/examples3d/","page":"3D Grid examples","title":"3D Grid examples","text":"(Image: )","category":"page"},{"location":"examples/examples3d/#Cross3d","page":"3D Grid examples","title":"Cross3d","text":"","category":"section"},{"location":"examples/examples3d/","page":"3D Grid examples","title":"3D Grid examples","text":"function cross3d()\n    X=collect(0:1:10)\n    Y=collect(0:1:10)\n    Z=collect(0:1:10)\n    grid=simplexgrid(X,Y,Z)\n\n    rect!(grid, (0,4,0), (10,6,2), region=2, bregions=[1,1,1,1,2,3])\n\n    rect!(grid, (4,0,2), (6,10,4), region=2, bregions=[ 4,4,4,4, (cur)-> cur == 3 ? 0 : 5 , 6] )\n\n    subgrid(grid,[2])\n\nend","category":"page"},{"location":"examples/examples3d/","page":"3D Grid examples","title":"3D Grid examples","text":"(Image: )","category":"page"},{"location":"examples/examples3d/","page":"3D Grid examples","title":"3D Grid examples","text":"function mask_bedges()\n    grid    = quadrilateral(hx=0.25, hy=0.25, hz=0.25)\n\n    bedgemask!(grid, [0.0, 0.0, 0.0], [0.0, 0.0, 1.0], 1)\n    bedgemask!(grid, [0.0, 0.0, 0.0], [0.0, 1.0, 0.0], 2)\n    bedgemask!(grid, [0.0, 1.0, 0.0], [0.0, 1.0, 1.0], 3)\n    bedgemask!(grid, [0.0, 0.0, 1.0], [0.0, 1.0, 1.0], 4)\n    bedgemask!(grid, [0.0, 1.0, 0.0], [0.0, 0.0, 1.0], 5)\n\n    true\nend","category":"page"},{"location":"examples/examples3d/","page":"3D Grid examples","title":"3D Grid examples","text":"","category":"page"},{"location":"examples/examples3d/","page":"3D Grid examples","title":"3D Grid examples","text":"This page was generated using Literate.jl.","category":"page"},{"location":"coordinatesystem/#Coordinate-systems","page":"Coordinate systems","title":"Coordinate systems","text":"","category":"section"},{"location":"coordinatesystem/","page":"Coordinate systems","title":"Coordinate systems","text":"Coordinate systems are described via abstract types. The list of coordinate systems can be obtained with the coordinatesystems method:","category":"page"},{"location":"coordinatesystem/","page":"Coordinate systems","title":"Coordinate systems","text":"using ExtendableGrids # hide\ncoordinatesystems() #hide","category":"page"},{"location":"coordinatesystem/#API","page":"Coordinate systems","title":"API","text":"","category":"section"},{"location":"coordinatesystem/","page":"Coordinate systems","title":"Coordinate systems","text":"Modules = [ExtendableGrids]\nPages = [\"coordinatesystem.jl\"]","category":"page"},{"location":"coordinatesystem/#ExtendableGrids.AbstractCoordinateSystem","page":"Coordinate systems","title":"ExtendableGrids.AbstractCoordinateSystem","text":"abstract type AbstractCoordinateSystem <: AbstractExtendableGridApexType\n\nApex type for coordinate systems\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Cartesian1D","page":"Coordinate systems","title":"ExtendableGrids.Cartesian1D","text":"abstract type Cartesian1D <: AbstractCoordinateSystem\n\n1D cartesion coordinate system (unknown x)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Cartesian2D","page":"Coordinate systems","title":"ExtendableGrids.Cartesian2D","text":"abstract type Cartesian2D <: AbstractCoordinateSystem\n\n2D cartesion coordinate system (unknowns x,y)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Cartesian3D","page":"Coordinate systems","title":"ExtendableGrids.Cartesian3D","text":"abstract type Cartesian3D <: AbstractCoordinateSystem\n\n2D cartesion coordinate system (unknowns x,y,z)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Cylindrical2D","page":"Coordinate systems","title":"ExtendableGrids.Cylindrical2D","text":"abstract type Cylindrical2D <: AbstractCoordinateSystem\n\n2D cylindrical coordinate system (unknowns r,z)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Cylindrical3D","page":"Coordinate systems","title":"ExtendableGrids.Cylindrical3D","text":"abstract type Cylindrical3D <: AbstractCoordinateSystem\n\n3D cylindrical coordinate system (unknowns r,ϕ,z)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Polar1D","page":"Coordinate systems","title":"ExtendableGrids.Polar1D","text":"abstract type Polar1D <: AbstractCoordinateSystem\n\n1D polar coordinate system (unknown r)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Polar2D","page":"Coordinate systems","title":"ExtendableGrids.Polar2D","text":"abstract type Polar2D <: AbstractCoordinateSystem\n\n2D polar coordinate system (unknowns r,ϕ)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Spherical1D","page":"Coordinate systems","title":"ExtendableGrids.Spherical1D","text":"abstract type Spherical1D <: AbstractCoordinateSystem\n\n1D spheriacal coordinate system (unknown r)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.Spherical3D","page":"Coordinate systems","title":"ExtendableGrids.Spherical3D","text":"abstract type Spherical3D <: AbstractCoordinateSystem\n\n3D spheriacal coordinate system (unknowns r,ϕ,θ)\n\n\n\n\n\n","category":"type"},{"location":"coordinatesystem/#ExtendableGrids.coordinatesystems-Tuple{}","page":"Coordinate systems","title":"ExtendableGrids.coordinatesystems","text":"coordinatesystems()\n\n\nList possible coordinate systems. These describe the meaning of the grid coordinates.\n\n\n\n\n\n","category":"method"}]
}
